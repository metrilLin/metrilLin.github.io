[{"categories":["国密"],"content":"国密ssl抓包分析 ","date":"2023-04-01","objectID":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/:0:0","tags":["国密"],"title":"国密ssl抓包分析","uri":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"categories":["国密"],"content":"国密SSL VPN握手抓包分析 握手流程如下 1. tcp三次握手 2. 客户端主动向服务端发送 client hello 3. 服务端向客户端返回 server hello 4. 服务端返回证书，server key exchange ，请求客户端证书，server hello done 5. 客户端上传自己的证书给服务端，client key exchange，传输协商后的密钥 6. 服务端验证客户端的证书，client key exchange，传输协商后的密钥 7. 服务端发送 change cipher spec、encrypted handshake 8. 握手协商完成，进行应用层面交互，通过前面的协商密钥来加密 ","date":"2023-04-01","objectID":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/:1:0","tags":["国密"],"title":"国密ssl抓包分析","uri":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"categories":["国密"],"content":"client hello ProtocolVersion 客户端向服务端发送client hello 用于向server提供客户端的密码套件版本，tls协议版本，会话标识 ，extension（有无externsion不影响tls的成功与否，只代表向server表示自己支持该能力），tls协议定义有四个版本号，为0x0301，0x0302,0x0303,0x0304,分别对应tls1.0 1.1 1.2 1.3 国密tls可能是担心与未来的TLS版本号冲突，所以使用了0x0101,这个给实现带来了很多的麻烦， 大部分网络库都是使用 \u003e= \u003c= 进行版本判断，会认为0x0101是一个无效的版本，需要将这块的判断进行逐一修改。 CipherSuite tls中使用的加密算法主要有非对称加密、摘要算法，对称加密。在ECC_SM4_SM3套件中，非对称加密算法为SM2（Sm2算法为一条全新的ECC椭圆曲线），对称加密算法为SM4，摘要算法为SM3。 根据《GMT 0024-2014 SSL VPN 技术规范》中，国密新增的密码套件如下 ","date":"2023-04-01","objectID":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/:1:1","tags":["国密"],"title":"国密ssl抓包分析","uri":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"categories":["国密"],"content":"server hello server hello与tls1.2基本一致，都是向客户端发送协议版本号，随机数以及返回server选定的加密套件。如果客户端client hello数据包中没有国密相关套件，那么只支持国密tls的网站将会直接发送alert close (测试站:https://ebssec.boc.cn) ","date":"2023-04-01","objectID":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/:1:2","tags":["国密"],"title":"国密ssl抓包分析","uri":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"categories":["国密"],"content":"Certificate 根据国密标准定义，服务器必须使用双证书模式，通常情况下，服务端只需要一张证书 签名时，服务器使用自己的私钥加密信息的摘要（签名），客户端使用服务器的公钥（包含在证书中）进行解密，对比该摘要是否正确，若正确，则客户端就确定了服务器的身份，即验签成功。 加密时，服务器和客户端协商出会话密钥（一般为对称密钥），会话密钥的产生根据密钥协商算法的不同，过程有所不同，但都会用到证书的公钥和私钥，也就是说证书也用在加密场景中。 而双证书则包括签名证书和加密证书两张证书，签名证书在签名时使用，仅仅用来验证身份，公钥以及私钥均由服务器自己产生，CA机构不负责其保管任务。 加密证书则是在密钥协商时使用，其私钥和公钥由CA机构产生，并且由CA存根 此外协议这没有规定清楚，证书的顺序应该是签名证书 + 证书链 + 加密证书，还是签名证书 + 加密证书 + 证书链，实现的时候需要注意此处的兼容性 ","date":"2023-04-01","objectID":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/:1:3","tags":["国密"],"title":"国密ssl抓包分析","uri":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"categories":["国密"],"content":"server key exchage \u0026\u0026 server hello done tls 1.2在server key exchange会返回给客户端相关的D-H算法参数，国密下这个数据包会返回用于客户端计算产生48字节的Pre-Master Secret（预主密钥） 但是国密ECC_SM4_SM3的这个server key exchange更像rsa，会话密钥由客户端来决定，客户端生成Pre-Master Secret，用SM2公钥加密后传送给服务器，对于客户端来说这个消息不处理也没关系，暂时不清楚这个ecc的ASN.1 Cert在这个套件里到底有啥用，等后续知道了补充 server hello done表示服务端给客户端握手所需要的全部数据已经发送完成了，等待后续客户端返回 ","date":"2023-04-01","objectID":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/:1:4","tags":["国密"],"title":"国密ssl抓包分析","uri":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"categories":["国密"],"content":"ClientKeyExchange 服务端发送SM2公钥（在加密证书中）,客户端生成Pre-Master Secret，用SM2公钥加密后传送给服务器。这块数据紧跟在ClientKeyExchange length后 ","date":"2023-04-01","objectID":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/:1:5","tags":["国密"],"title":"国密ssl抓包分析","uri":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"categories":["国密"],"content":"ChangeCipherSpec 客户端发送Change Cipher Spec消息告诉服务端，接下来的数据使用协商好的会话密钥来通信，也就是发送一个Encrypted Handshake Message消息，服务端接收之后，也会返回一个 ChangeCipherSpec保证双方的加解密正常。 握手主流程基本结束，后续就是两边的业务数据的收发。 ","date":"2023-04-01","objectID":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/:1:6","tags":["国密"],"title":"国密ssl抓包分析","uri":"/%E5%9B%BD%E5%AF%86tls%E6%8F%A1%E6%89%8B%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/"},{"categories":["驱动"],"content":"基于KMDF的磁盘写保护 ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:0:0","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"前言 Windows上有几种不同类型的过滤器驱动程序，从文件系统过滤器到Ndis封包过滤器以及特定的PnP设备过滤器等。本文主要讲的是磁盘设备过滤器驱动(Disk Device Filter Driver)，其可以附加到本机磁盘驱动器上，过滤系统中的所有磁盘设备，实现对特定磁盘写保护的功能。 ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:1:0","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"Windows 驱动框架部分名词解释 本文涉及到的名词及缩写，在介绍设备过滤器驱动时简单科普部分名词解释。 ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:2:0","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"Windows设备对象堆栈 操作系统按照设备对象来表示设备，一个或多个设备对象与每个设备相关联，通过操作设备对象来对设备进行相关操作。 FDO：全称为Functional Device Object，表示功能设备对象，是设备的主要驱动程序； PDO：全称为Physical Device Object，表示物理设备对象，但不一定是物理设备，本质是总线上的设备与总线本身之间的接口； FiDO：过滤器驱动，属于可选驱动程序，在FDO上方的被称为upper filter上层过滤器，在FDO下方的被称为low filter 下层过滤器。 ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:2:1","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"PnP 表示即插即用设备 ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:2:2","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"IRP IRP(I/O request packets)是io数据请求包的缩写，是一种复杂的数据结构，用于与内核模式驱动程序进行通信，发送到设备驱动程序的大部分请求都打包在I/O请求数据包，详细的数据结构可以看msdn：irp结构。 ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:2:3","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"磁盘设备过滤器驱动实现 FIDO可以是上层过滤器或下层过滤器，上层过滤器在设备堆栈的FDO之上实例化，所以上层过滤器可以在设备的FDO设备对象看到之前，处理发送到FDO设备的IRP操作，本文主要讲的就是一个基于KMDF框架的上层过滤器驱动。 安装某一类设备驱动过滤器时，会在对应设备类(详细设备类及GUID)下注册对应的UpperFilters及LowerFilters键值，在收到此类设备的PnP时，系统会尝试启动对应的过滤器驱动，下图为本文的磁盘设备上层过滤器驱动的注册表值： 磁盘设备 Class = DiskDrive ClassGuid = {4d36e967-e325-11ce-bfc1-08002be10318} WDF过滤器的结构与FDO相同，在DriverEntry中创建WDFDRIVER对象并与框架链接，对于过滤器驱动，当PnP Manager枚举指定设备的驱动程序时，将会调用EvtDriverDeviceAdd事件用于处理回调。 ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:3:0","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"DriverEntry 在主函数中没有处理太多逻辑，主要是实例化WdfDriver对象并连接框架： daextern \"C\" NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { WDF_DRIVER_CONFIG config; NTSTATUS status; WDF_DRIVER_CONFIG_INIT(\u0026config, DiskProtEvtDeviceAdd); //创建一个wdf驱动对象 status = WdfDriverCreate(DriverObject, RegistryPath, WDF_NO_OBJECT_ATTRIBUTES, \u0026config, WDF_NO_HANDLE); if (!NT_SUCCESS(status)) { #if DBG DbgPrint(\"WdfDriverCreate failed - 0x%x\\n\",status); #endif return status; } return STATUS_SUCCESS; } ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:3:1","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"EvtDriverDeviceAdd _Use_decl_annotations_ NTSTATUS DiskProtEvtDeviceAdd(WDFDRIVER Driver, PWDFDEVICE_INIT DeviceInit) { NTSTATUS status; WDF_OBJECT_ATTRIBUTES wdfObjectAttr; WDFDEVICE wdfDevice; PDISKPROT_DEVICE_CONTEXT devContext; WDF_IO_QUEUE_CONFIG ioQueueConfig; //PnP管理器报告新设备存在时 回调该 api 并执行设备初始化操作 #if DBG DbgPrint(\"DiskProtEvtDeviceAdd: Adding device...\\n\"); #endif UNREFERENCED_PARAMETER(Driver); //PnP管理器报告新设备存在时 回调该 api 并执行设备初始化操作 WdfFdoInitSetFilter(DeviceInit); // // 指定设备上下文 // WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(\u0026wdfObjectAttr, DISKPROT_DEVICE_CONTEXT); status = WdfDeviceCreate(\u0026DeviceInit, \u0026wdfObjectAttr, \u0026wdfDevice); if (!NT_SUCCESS(status)) { #if DBG DbgPrint(\"WdfDeviceCreate failed - 0x%x\\n\", status); #endif return status; } devContext = DiskProtGetDeviceContext(wdfDevice); devContext-\u003eWdfDevice = wdfDevice; //创建默认队列 以及注册相关回调函数 WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(\u0026ioQueueConfig, WdfIoQueueDispatchParallel); ioQueueConfig.EvtIoRead = DiskProtEvtRead; ioQueueConfig.EvtIoWrite = DiskProtEvtWrite; ioQueueConfig.EvtIoDeviceControl = DiskProtEvtDeviceControl; // // 创建WDF队列 // status = WdfIoQueueCreate(devContext-\u003eWdfDevice, \u0026ioQueueConfig, WDF_NO_OBJECT_ATTRIBUTES, WDF_NO_HANDLE); if (!NT_SUCCESS(status)) { #if DBG DbgPrint(\"WdfIoQueueCreate failed - 0x%x\\n\", status); #endif return status; } return STATUS_SUCCESS; } ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:3:2","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"EvtIoDeviceControl kmdf框架通过EvtIoDeviceControl处理接收到的对应设备的IOCTL请求，本文主要实现磁盘的写保护功能，也就是需要响应IOCTL_DISK_IS_WRITABLE 控制请求，通过WdfRequestComplete返回这个磁盘受到保护的状态码STATUS_MEDIA_WRITE_PROTECTED。 _Use_decl_annotations_ VOID DiskProtEvtDeviceControl(WDFQUEUE Queue, WDFREQUEST Request, size_t OutputBufferLength, size_t InputBufferLength, ULONG IoControlCode) { PDISKPROT_DEVICE_CONTEXT devContext; devContext = DiskProtGetDeviceContext(WdfIoQueueGetDevice(Queue)); UNREFERENCED_PARAMETER(OutputBufferLength); UNREFERENCED_PARAMETER(InputBufferLength); #if DBG DbgPrint(\"DiskProtEvtDeviceControl -- Request 0x%p\\n\", Request); #endif //获取磁盘是否只读IOCTL if (IoControlCode == IOCTL_DISK_IS_WRITABLE) { if(DiskProtGetBusType(devContext) == STORAGE_BUS_TYPE::BusTypeUsb) { //返回一个只读的状态码 WdfRequestComplete(Request, STATUS_MEDIA_WRITE_PROTECTED); return; } FilterSendWithCallback(Request, devContext); return; } FilterSendAndForget(Request, devContext); } 另一个问题，如何判断这个磁盘是需要进行写入保护的磁盘？此处的做法是通过磁盘的IOCTL_STORAGE_QUERY_PROPERTY 来获取当前设备对象的磁盘信息，通过获取总线结构，判断当前磁盘类型，只对一类总线结构的类型进行写保护，同时此处也可以自由拓展，由应用层来决定对某些磁盘的保护控制。 _Use_decl_annotations_ STORAGE_BUS_TYPE DiskProtGetBusType(PDISKPROT_DEVICE_CONTEXT devContext) { WDFIOTARGET hidTarget = nullptr; WDF_MEMORY_DESCRIPTOR outputDescriptor; STORAGE_PROPERTY_QUERY query = {}; PSTORAGE_DESCRIPTOR_HEADER descriptor = nullptr; PSTORAGE_DEVICE_DESCRIPTOR DeviceDescriptor = nullptr; STORAGE_BUS_TYPE currentBusType = STORAGE_BUS_TYPE::BusTypeUnknown; hidTarget = WdfDeviceGetIoTarget(devContext-\u003eWdfDevice); WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(\u0026outputDescriptor, (PVOID)\u0026query, sizeof(STORAGE_PROPERTY_QUERY)); query.PropertyId = StorageDeviceProperty; query.QueryType = PropertyStandardQuery; descriptor = (PSTORAGE_DESCRIPTOR_HEADER)\u0026query; NTSTATUS status = WdfIoTargetSendIoctlSynchronously(hidTarget, NULL, IOCTL_STORAGE_QUERY_PROPERTY, \u0026outputDescriptor, \u0026outputDescriptor, NULL, NULL); if (!NT_SUCCESS(status)) { DbgPrint(\"DiskProtEvtDeviceControl WdfIoTargetSendIoctlSynchronously failed 0x%x\\n\", status); return currentBusType; } else { DbgPrint(\"DiskProtEvtDeviceControl %d\\n\", descriptor-\u003eSize); ULONG bufferLength = 0; bufferLength = descriptor-\u003eSize; NT_ASSERT(bufferLength \u003e= sizeof(STORAGE_PROPERTY_QUERY)); bufferLength = max(bufferLength, sizeof(STORAGE_PROPERTY_QUERY)); descriptor = (PSTORAGE_DESCRIPTOR_HEADER)ExAllocatePoolWithTag(NonPagedPoolNx, bufferLength, 'GYqw'); RtlZeroMemory(\u0026query, sizeof(STORAGE_PROPERTY_QUERY)); query.PropertyId = StorageDeviceProperty; query.QueryType = PropertyStandardQuery; RtlCopyMemory(descriptor, \u0026query, sizeof(STORAGE_PROPERTY_QUERY)); //开辟完空间重新获取数据 WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(\u0026outputDescriptor, (PVOID)descriptor, bufferLength); status = WdfIoTargetSendIoctlSynchronously(hidTarget, NULL, IOCTL_STORAGE_QUERY_PROPERTY, \u0026outputDescriptor, \u0026outputDescriptor, NULL, NULL); DeviceDescriptor = (PSTORAGE_DEVICE_DESCRIPTOR)descriptor; DbgPrint(\"DiskProtEvtDeviceControl StorageDeviceProperty %d\\n\", DeviceDescriptor-\u003eBusType); currentBusType = DeviceDescriptor-\u003eBusType; FREE_POOL(DeviceDescriptor); } return currentBusType; } ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:3:3","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"Install inf 需要在inf安装文件中指定需要附加在哪一类设备以及需要提供相应的GUID，此外还需要在注册表中指定为`UpperFilters，此外在inf中指定驱动的启动类型，SERVICE_BOOT_START表示由操作系统(OS)加载程序启动的驱动 [Version] Signature = \"$Windows NT$\" Class = %ClassNameToFilter% ClassGUID = %ClassGUIDToFilter% Provider = %Provider% DriverVer = CatalogFile = DiskProt.cat [DefaultInstall.NT] CopyFiles = @DiskProt.sys Addreg = DiskProt.AddReg [DestinationDirs] DefaultDestDir = 12 [DiskProt.AddReg] HKLM, System\\CurrentControlSet\\Control\\Class\\%ClassGUIDToFilter%, UpperFilters, 0x00010008, %DriverName% [DefaultInstall.NT.Services] AddService = DiskProt, , DiskProt.Service.Install [DiskProt.Service.Install] DisplayName = %ServiceName% Description = %ServiceDescription% ServiceBinary = %12%\\%DriverName%.sys ServiceType = 1 ;SERVICE_KERNEL_DRIVER StartType = 0 ;SERVICE_BOOT_START ErrorControl = 1 ;SERVICE_ERROR_NORMAL AddReg = KMDFVerifierAddReg [KMDFVerifierAddReg] HKR, Parameters\\Wdf,VerifierOn,0x00010001,1 HKR, Parameters\\Wdf,VerboseOn,0x00010001,1 HKR, Parameters\\Wdf,DbgBreakOnError,0x00010001,1 [SourceDisksFiles] DiskProt.sys=1 [SourceDisksNames] 1 = %DiskName% [Strings] ClassGUIDToFilter = \"{4d36e967-e325-11ce-bfc1-08002be10318}\" ClassNameToFilter = \"DiskDrive\" Provider = \"yunshanwuyin\" ServiceDescription = \"disk protect\" ServiceName = \"DiskProt\" DriverName = \"DiskProt\" DiskName = \"DiskProt Installation Disk\" ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:3:4","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"效果 ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:4:0","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"注意事项 关于磁盘相关的驱动，最好配置双击调试进行测试，否则可能由于某些代码或安装问题导致蓝屏，处理起来会很麻烦，数据的安全性也无法保证。 ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:5:0","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["驱动"],"content":"扩展 1.存储类设备除了使用驱动进行控制，应用层通过修改注册表以及策略组，也可以达到只读、禁用等功能； 应用层禁用USB设备 注册表位置：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\USBSTOR 修改start项：3表示启用、4表示禁用 应用层限制USB存储设备写保护 注册表位置：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\StorageDevicePolicies 修改WriteProtect项：0表示不限制只读，1表示限制为只读 修改注册表的策略并不是实时生效的，在修改完之后重新接入U盘，策略才会生效 2.手机类型设备属于WPD设备，控制需要使用其他的ClassGuid进行管理，在应用层想要限制WPD设备的相关操作，需要配置策略组，home版本没有策略组的同样可以通过修改注册表来解决，如果注册表中无下列项，可自行创建。 应用层WPD设备禁用以及只读策略 注册表位置：HKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows\\RemovableStorageDevices\\{6AC27878-A6FA-4155-BA85-F98F491D4F33} 包含两个项Deny_Read，`Deny_Write： 0表示正常读取、写入1表示禁用 开启策略：wpd的策略设置完成之后还需要配置开启策略的选项 注册表位置：HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices\\{F33FDC04-D1AC-4E8E-9A30-19BBD4B108AE} 包含两个项Deny_Read,Deny_Write：0表示禁用对应的读取/写入策略、1表示启用策略 ","date":"2022-07-10","objectID":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/:6:0","tags":["驱动"],"title":"基于KMDF的磁盘写保护","uri":"/%E5%9F%BA%E4%BA%8Ekmdf%E5%AE%9E%E7%8E%B0%E7%A3%81%E7%9B%98%E5%86%99%E4%BF%9D%E6%8A%A4/"},{"categories":["windows"],"content":"windows Sysmon Sysmon可以通过系统服务和驱动程序，实时记录进程创建，文件访问以及网络信息的记录，并把相关的信息写入并展示在windows的日志事件里。 ","date":"2022-06-12","objectID":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/:0:0","tags":["windows"],"title":"Sysmon的配置与使用","uri":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["windows"],"content":"安装 msdn 下载链接: https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon 下载解压后，挪动到C:\\\\Windows下 ","date":"2022-06-12","objectID":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:0","tags":["windows"],"title":"Sysmon的配置与使用","uri":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["windows"],"content":"配置 安装以及启动sysmon需要配置xml config文件 https://github.com/SwiftOnSecurity/sysmon-config 安装 Sysmon64 -accepteula -i sysmonconfig-export.xml Sysmon64 -c sysmonconfig-export.xml 安装的同时会安装驱动SysmonDrv 卸载 # 通过以下方式对Sysmon进行卸载操作 Sysmon64.exe -u ","date":"2022-06-12","objectID":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:0","tags":["windows"],"title":"Sysmon的配置与使用","uri":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["windows"],"content":"使用 启动sysmon后，sysmon会根据配置文件的配置规则，对系统进行监控，并输出windwos日志事件，可以使用eventvwr.msc 定位到 应用程序和服务日志-Microsoft-Windows-Sysmon-Operational sysmon 是一个闭源的windows系统服务，只能通过config.xml 文件对各项进行配置，使用windows 系统事件订阅对事件进行订阅与过滤。 ","date":"2022-06-12","objectID":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/:3:0","tags":["windows"],"title":"Sysmon的配置与使用","uri":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["windows"],"content":"兼容性 完整的功能： 客户端：Windows 8.1 及更高版本。 服务器：Windows Server 2012 及更高版本。 在windows 7及以下，不支持DNSEvent（DNS 查询）事件 ","date":"2022-06-12","objectID":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:0","tags":["windows"],"title":"Sysmon的配置与使用","uri":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["windows"],"content":"事件文档说明 一共支持28个系统ID事件，直接看微软文档 https://learn.microsoft.com/en-us/sysinternals/downloads/sysmon#events. 设置订阅的过滤条件主要通过上文的xml config文件在安装的时候进行指定 ","date":"2022-06-12","objectID":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:0","tags":["windows"],"title":"Sysmon的配置与使用","uri":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["windows"],"content":"订阅事件 WinLogBeat + Elastic监控 ​ es提供已有工具 WinLogBeat,WinLogBeat以系统服务的方式安装在windows设备上，通过配置订阅可以转发到Elastic或者LogStash上详情可以专门看es文档 C++订阅SysMon代码示例，通过EvtSubscribe订阅事件，接收类似eventView事件回调（详情为xml格式） #include \u003cwindows.h\u003e#include \u003cconio.h\u003e#include \u003cstdio.h\u003e#include \u003cwinevt.h\u003e #pragma comment(lib, \"wevtapi.lib\") DWORD WINAPI SubscriptionCallback(EVT_SUBSCRIBE_NOTIFY_ACTION action, PVOID pContext, EVT_HANDLE hEvent); DWORD PrintEvent(EVT_HANDLE hEvent); int main(void) { DWORD status = ERROR_SUCCESS; EVT_HANDLE hSubscription = NULL; LPWSTR pwsPath = L\"Microsoft-Windows-Sysmon/Operational\"; LPWSTR pwsQuery = L\"\u003cQueryList\u003e\\n\" \"\u003cQuery Id=\\\"0\\\"Path=\\\"Microsoft-Windows-Sysmon/Operational\\\"\u003e\\n\" \"\u003cSelect Path=\\\"Microsoft-Windows-Sysmon/Operational\\\"\u003e*\u003c/Select\u003e\\n\" \"\u003c/Query\u003e\\n\" \"\u003c/QueryList\u003e\"; // Subscribe to events beginning with the oldest event in the channel. The subscription // will return all current events in the channel and any future events that are raised // while the application is active. hSubscription = EvtSubscribe(NULL, NULL, pwsPath, NULL, NULL, NULL, (EVT_SUBSCRIBE_CALLBACK)SubscriptionCallback, EvtSubscribeStartAtOldestRecord); if (NULL == hSubscription) { status = GetLastError(); if (ERROR_EVT_CHANNEL_NOT_FOUND == status) wprintf(L\"Channel %s was not found.\\n\", pwsPath); else if (ERROR_EVT_INVALID_QUERY == status) // You can call EvtGetExtendedStatus to get information as to why the query is not valid. wprintf(L\"The query \\\"%s\\\"is not valid.\\n\", pwsQuery); else wprintf(L\"EvtSubscribe failed with %lu.\\n\", status); goto cleanup; } wprintf(L\"Hit any key to quit\\n\\n\"); while (!_kbhit()) Sleep(10); cleanup: if (hSubscription) EvtClose(hSubscription); return 0; } // The callback that receives the events that match the query criteria. DWORD WINAPI SubscriptionCallback(EVT_SUBSCRIBE_NOTIFY_ACTION action, PVOID pContext, EVT_HANDLE hEvent) { UNREFERENCED_PARAMETER(pContext); DWORD status = ERROR_SUCCESS; switch(action) { // You should only get the EvtSubscribeActionError action if your subscription flags // includes EvtSubscribeStrict and the channel contains missing event records. case EvtSubscribeActionError: if (ERROR_EVT_QUERY_RESULT_STALE == (DWORD)hEvent) { wprintf(L\"The subscription callback was notified that event records are missing.\\n\"); // Handle if this is an issue for your application. } else { wprintf(L\"The subscription callback received the following Win32 error: %lu\\n\", (DWORD)hEvent); } break; case EvtSubscribeActionDeliver: if (ERROR_SUCCESS != (status = PrintEvent(hEvent))) { goto cleanup; } break; default: wprintf(L\"SubscriptionCallback: Unknown action.\\n\"); } cleanup: if (ERROR_SUCCESS != status) { // End subscription - Use some kind of IPC mechanism to signal // your application to close the subscription handle. } return status; // The service ignores the returned status. } // Render the event as an XML string and print it. DWORD PrintEvent(EVT_HANDLE hEvent) { DWORD status = ERROR_SUCCESS; DWORD dwBufferSize = 0; DWORD dwBufferUsed = 0; DWORD dwPropertyCount = 0; LPWSTR pRenderedContent = NULL; if (!EvtRender(NULL, hEvent, EvtRenderEventXml, dwBufferSize, pRenderedContent, \u0026dwBufferUsed, \u0026dwPropertyCount)) { if (ERROR_INSUFFICIENT_BUFFER == (status = GetLastError())) { dwBufferSize = dwBufferUsed; pRenderedContent = (LPWSTR)malloc(dwBufferSize); if (pRenderedContent) { EvtRender(NULL, hEvent, EvtRenderEventXml, dwBufferSize, pRenderedContent, \u0026dwBufferUsed, \u0026dwPropertyCount); } else { wprintf(L\"malloc failed\\n\"); status = ERROR_OUTOFMEMORY; goto cleanup; } } if (ERROR_SUCCESS != (status = GetLastError())) { wprintf(L\"EvtRender failed with %d\\n\", status); goto cleanup; } } wprintf(L\"%s\\n\\n\", pRenderedContent); cleanup: if (pRenderedContent) free(pRenderedContent); return status; } ","date":"2022-06-12","objectID":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/:6:0","tags":["windows"],"title":"Sysmon的配置与使用","uri":"/sysmon%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["C++"],"content":"C++中的RTTI技术 ","date":"2022-01-09","objectID":"/c-rtti%E6%8A%80%E6%9C%AF/:0:0","tags":["C++"],"title":"C++中的RTTI技术","uri":"/c-rtti%E6%8A%80%E6%9C%AF/"},{"categories":["C++"],"content":"前言 RTTI的全称是“Runtime Type Identification”，意思是运行时类型识别。C++引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型。 原因就是由于存在多态行为，基类指针或者引用指向一个派生类，而基类指针指向的真正的类型，在编译时无法得知 Base *b = new Derived; Base \u0026b1 = *b; 编译时期无法获取B的具体类型，只能通过RTTI，C++主要通过以下几个操作提供RTTI： typeid运算符 type_info 类 dynamic_cast运算符 ","date":"2022-01-09","objectID":"/c-rtti%E6%8A%80%E6%9C%AF/:1:0","tags":["C++"],"title":"C++中的RTTI技术","uri":"/c-rtti%E6%8A%80%E6%9C%AF/"},{"categories":["C++"],"content":"typeid与type_info typeid是C++的关键字，用来获取类型、变量、表达式的类型信息，适用与C++基础类型、内置类、用户自定义类、模板类等有如下两种形式 typeid(type) typeid(expr) 用法如下，本文使用msvc编译器 #include \u003ciostream\u003e#include \u003ctypeinfo\u003e#include \u003ccassert\u003eusing namespace std; class A{ public: A() = default; }; int main() { short s = 2; unsigned ui = 10; int i = 10; char ch = 'a'; float f = 1.0f; double d = 2; A a; cout\u003c\u003ctypeid(s).name()\u003c\u003cendl; // short cout\u003c\u003ctypeid(ui).name()\u003c\u003cendl; // unsigned int cout\u003c\u003ctypeid(i).name()\u003c\u003cendl; // int cout\u003c\u003ctypeid(ch).name()\u003c\u003cendl; // char cout\u003c\u003ctypeid(f).name()\u003c\u003cendl; // float cout\u003c\u003ctypeid(d).name()\u003c\u003cendl; // double cout \u003c\u003c typeid(a).name() \u003c\u003cendl; //class A assert(typeid(a) == typeid(A)); return 0; } type_info类就是typeid操作符返回的对象引用，ISO C++标准并没有对type_info有明确的要求，所以每个编译厂商对对type_info类的实现各不相同，所以上面的代码输出的type_info::name方法在不同编译器下的输出各不相同，比如int类型分别输出int(msvc)与i(gcc、mingw)。又比如typeid(std::vector\u003cint\u003e).name() 在gcc下会输出St6vectorIiSaIiEE,这是由于gcc编译器的Name mangling，如果需要msvc一样的输出可以使用下面的代码 #include \u003ccxxabi.h\u003e#include \u003ciostream\u003e#include \u003cmemory\u003e#include \u003cstring\u003e#include \u003ctypeinfo\u003e#include \u003cvector\u003e std::string demangle(const char* name) { int status = -4; std::unique_ptr\u003cchar, void(*)(void*)\u003e res { abi::__cxa_demangle(name, NULL, NULL, \u0026status), std::free }; return (status==0) ? res.get() : name ; } int main() { std::vector\u003cint\u003e v; std::cout \u003c\u003c \"before: \" \u003c\u003c typeid(v).name() \u003c\u003c \" after: \" \u003c\u003c demangle(typeid(v).name()) \u003c\u003c std::endl; return 0; } ","date":"2022-01-09","objectID":"/c-rtti%E6%8A%80%E6%9C%AF/:2:0","tags":["C++"],"title":"C++中的RTTI技术","uri":"/c-rtti%E6%8A%80%E6%9C%AF/"},{"categories":["C++"],"content":"dynamic_cast dynamic_cast (expression) 此运算符运行时把expression转换成Type类型，使程序能够安全的进行转化类型，dynamic_cast提供两种转化方式 基类指针转化为派生类指针 基类的左值转化为派生类的引用 把一个派生类的指针或引用转换成其基类的指针或引用总是安全的，根据对象的内存布局，派生类的对象中必然存在基类的子对象，通过基类的指针或引用对派生类对象进行的所有基类的操作都是合法和安全的。而向下转换有潜在的危险性，因为基类的指针可以指向基类对象或者其他派生类的对象，dynamic_cast可以处理这一问题 #include \u003ciostream\u003e class A{ public: A() = default; virtual void Print() { std::cout\u003c\u003c\"This is class A.\"\u003c\u003cstd::endl; } }; class B { public: B() = default; virtual void Print() { std::cout\u003c\u003c\"This is class B.\"\u003c\u003cstd::endl; } }; class C : public A, public B { public: void Print() { std::cout\u003c\u003c\"This is class C.\"\u003c\u003cstd::endl; } }; int main() { A *pA = new C; C* pC = dynamic_cast\u003cC*\u003e(pA); if (pC != nullptr){ pC-\u003ePrint(); } delete pA; pC = nullptr; return 0; } 除非子类指针通过dynamic_cast转化成父类（向上转换）这种情况以外， dynamic_cast要求类必须是多态类型 需要带virtual 否则会报错 (source type is not polymorphic) 根据C++对象模型，对象的type_info被存在了虚表的首部，所以要使用dynamic_cast对象必须有多态，然后运行时期比对要转换的类型是否和type_info中记录的类型相同即可 ","date":"2022-01-09","objectID":"/c-rtti%E6%8A%80%E6%9C%AF/:3:0","tags":["C++"],"title":"C++中的RTTI技术","uri":"/c-rtti%E6%8A%80%E6%9C%AF/"},{"categories":["chromium"],"content":"Widevine Cdm ","date":"2021-07-15","objectID":"/widevine-cdm/:0:0","tags":["chromium"],"title":"chromium添加Widevine","uri":"/widevine-cdm/"},{"categories":["chromium"],"content":"前言 Widevine是google推出的一种DRM，支持从google指定的服务器上，下载经google加密的版权文件，如视频、应用等。 ","date":"2021-07-15","objectID":"/widevine-cdm/:1:0","tags":["chromium"],"title":"chromium添加Widevine","uri":"/widevine-cdm/"},{"categories":["chromium"],"content":"查看组件状态 chrome://components 目前编译的 chromium 是不带 Widevine CDM的 ","date":"2021-07-15","objectID":"/widevine-cdm/:2:0","tags":["chromium"],"title":"chromium添加Widevine","uri":"/widevine-cdm/"},{"categories":["chromium"],"content":"Widevine 作用 可为Web浏览器播放DRM内容（=受保护的音频/视频文件） Amazon Prime Video，BBC，Hulu，Netflix，Spotify和Disney 等网站使用DRM加密 ","date":"2021-07-15","objectID":"/widevine-cdm/:3:0","tags":["chromium"],"title":"chromium添加Widevine","uri":"/widevine-cdm/"},{"categories":["chromium"],"content":"无 Widevine 造成的影响 以netflix进行测试 无Widevine CDM时无法正常DRM加密的资源 ","date":"2021-07-15","objectID":"/widevine-cdm/:3:1","tags":["chromium"],"title":"chromium添加Widevine","uri":"/widevine-cdm/"},{"categories":["chromium"],"content":"解决方法 将Widevine 添加进chrome 开启编译选项 在编译目录（out/Default/args.gn），使用gn args时会默认生成，在args.gn下添加 enable_widevine = true 开启并重新编译,或者可以设置 gn --args=\"enable_widevine = true\" 版本为0.0.0.0 表示当前chrmium路径下无该插件。 源码component_updater 自动更新 组件会注册更新程序 chrome/browser/chrome_browser_main.cc:1589 if (!parsed_command_line().HasSwitch(switches::kDisableComponentUpdate)) { component_updater::RegisterComponentsForUpdate(profile_-\u003eIsOffTheRecord(), profile_-\u003eGetPrefs()); } 一起看一下updater的实现 components/component_updater/configurator_impl.cc:34 namespace { // Default time constants. const int kDelayOneMinute = 60; const int kDelayOneHour = kDelayOneMinute * 60; } // namespace ... int ConfiguratorImpl::InitialDelay() const { if (initial_delay_) return initial_delay_; return fast_update_ ? 10 : kDelayOneMinute; } int ConfiguratorImpl::NextCheckDelay() const { return 5 * kDelayOneHour; } int ConfiguratorImpl::OnDemandDelay() const { return fast_update_ ? 2 : (30 * kDelayOneMinute); } int ConfiguratorImpl::UpdateDelay() const { return fast_update_ ? 10 : (15 * kDelayOneMinute); } updater调用 components/component_updater/component_updater_service.cc void CrxUpdateService::Start() { DCHECK(thread_checker_.CalledOnValidThread()); VLOG(1) \u003c\u003c \"CrxUpdateService starting up. \" \u003c\u003c \"First update attempt will take place in \" \u003c\u003c config_-\u003eInitialDelay() \u003c\u003c \" seconds. \" \u003c\u003c \"Next update attempt will take place in \" \u003c\u003c config_-\u003eNextCheckDelay() \u003c\u003c \" seconds. \"; scheduler_-\u003eSchedule( base::TimeDelta::FromSeconds(config_-\u003eInitialDelay()), base::TimeDelta::FromSeconds(config_-\u003eNextCheckDelay()), base::BindRepeating( base::IgnoreResult(\u0026CrxUpdateService::CheckForUpdates), base::Unretained(this)), base::DoNothing()); } 也就是说 components中加载的程序有注册自动更新的功能的话,会在一定时间后(看代码应该是6min) 开始更新, 这个时间可以修改,所以应该只需要编译时开启 Widevine组件,使用时chromium中会自动更新 监控了一段时间确实 status确实会对每个组件进行更新 如果是这么处理的话,可以将自己的插件附带进浏览器,编译时自动加载出来,实现上来并不复杂 ","date":"2021-07-15","objectID":"/widevine-cdm/:3:2","tags":["chromium"],"title":"chromium添加Widevine","uri":"/widevine-cdm/"},{"categories":["chromium"],"content":"chrome单元测试 单独编译chromium的Gtest ","date":"2021-04-15","objectID":"/%E5%8D%95%E5%85%83%E8%B0%83%E8%AF%95demo%E7%BC%96%E8%AF%91/:0:0","tags":["chromium"],"title":"单独编译chromium的Gtest","uri":"/%E5%8D%95%E5%85%83%E8%B0%83%E8%AF%95demo%E7%BC%96%E8%AF%91/"},{"categories":["chromium"],"content":"使用 ","date":"2021-04-15","objectID":"/%E5%8D%95%E5%85%83%E8%B0%83%E8%AF%95demo%E7%BC%96%E8%AF%91/:1:0","tags":["chromium"],"title":"单独编译chromium的Gtest","uri":"/%E5%8D%95%E5%85%83%E8%B0%83%E8%AF%95demo%E7%BC%96%E8%AF%91/"},{"categories":["chromium"],"content":"编译单元测试模块 chromium 中以 *unittest 命名的文件为可以使用goole test进行单元编译，适用于测试单元模块的正确性。 #编译gn中的大模块(可以从包含unittest 的build.gn中找到) autoninja -C out\\win_r net_unittests ","date":"2021-04-15","objectID":"/%E5%8D%95%E5%85%83%E8%B0%83%E8%AF%95demo%E7%BC%96%E8%AF%91/:1:1","tags":["chromium"],"title":"单独编译chromium的Gtest","uri":"/%E5%8D%95%E5%85%83%E8%B0%83%E8%AF%95demo%E7%BC%96%E8%AF%91/"},{"categories":["chromium"],"content":"从大模块中运行单元 eg:ssl_connect_job_unittest.cc TEST_F(SOCKSConnectJobTest, DisableSecureDns) { for (bool disable_secure_dns : {false, true}) { TestConnectJobDelegate test_delegate; SOCKSConnectJob socks_connect_job( DEFAULT_PRIORITY, SocketTag(), \u0026common_connect_job_params_, CreateSOCKSParams(SOCKSVersion::V4, disable_secure_dns), \u0026test_delegate, nullptr /* net_log */); ASSERT_THAT(socks_connect_job.Connect(), test::IsError(ERR_IO_PENDING)); EXPECT_EQ(disable_secure_dns, host_resolver_.last_secure_dns_mode_override().has_value()); if (disable_secure_dns) { EXPECT_EQ(net::SecureDnsMode::kOff, host_resolver_.last_secure_dns_mode_override().value()); } } } cmd 执行 net_unittests.exe --gtest_filter=*SOCKSConnectJobTest.DisableSecureDns* ","date":"2021-04-15","objectID":"/%E5%8D%95%E5%85%83%E8%B0%83%E8%AF%95demo%E7%BC%96%E8%AF%91/:1:2","tags":["chromium"],"title":"单独编译chromium的Gtest","uri":"/%E5%8D%95%E5%85%83%E8%B0%83%E8%AF%95demo%E7%BC%96%E8%AF%91/"},{"categories":["C++"],"content":"C++中的断言(assert与static_assert) ","date":"2021-03-15","objectID":"/c-11%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80static_assert/:0:0","tags":["C++"],"title":"C++中的断言(assert与static_assert)","uri":"/c-11%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80static_assert/"},{"categories":["C++"],"content":"assert assert被C/C++用来判断某些条件是否成立，比如判断某些参数是否合法,指针类型的大小sizeof(void*)是否大于8, 或者判断malloc返回的指针是否为null。 assert的函数申明如下： void assert( int expression ); 如果expression为0，即false，assert就会把函数名，源代码文件名、当前行号发送给标准错误stderr，然后调用abort()终止执行。 ","date":"2021-03-15","objectID":"/c-11%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80static_assert/:1:0","tags":["C++"],"title":"C++中的断言(assert与static_assert)","uri":"/c-11%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80static_assert/"},{"categories":["C++"],"content":"assert使用时机 assert一般用于判断逻辑上一定为真的条件，如果条件不符合就会导致未定义行为（undefined behavior时，就可以使用assert，提前发现问题并处置。 assert只适合在debug版本中进行测试，release版本中应当禁用assert。C/C++提供了NDEBUG宏用于控制assert的行为，assert是默认生效的，如果定义了NDEBUG宏，assert就不会生效。 #include \u003ciostream\u003e#include \u003cassert.h\u003e void TestAssert(const int \u0026num){ assert(num == 0);// 断言成功 assert(num \u003e0); //断言失败 } int main() { TestAssert(0); return 0; } 输出如下： Assertion failed: num \u003e0, file main.cpp, line 6 ","date":"2021-03-15","objectID":"/c-11%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80static_assert/:1:1","tags":["C++"],"title":"C++中的断言(assert与static_assert)","uri":"/c-11%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80static_assert/"},{"categories":["C++"],"content":"assert 添加附加信息 没有标准化接口可以向 assert 错误添加附加消息。一种可移植的方法是使用逗号运算符，前提是它没有被重载，另一种是使用带有字符串文字的 \u0026\u0026 ： assert((\"There are five lights\", 2 + 2 == 5)); assert( (2 + 2 == 5) \u0026\u0026 \"There are five lights\"); ","date":"2021-03-15","objectID":"/c-11%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80static_assert/:1:2","tags":["C++"],"title":"C++中的断言(assert与static_assert)","uri":"/c-11%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80static_assert/"},{"categories":["C++"],"content":"static_assert static_assert是C++11新增的静态断言关键字，assert其实只是一个宏，在运行时断言，只有当执行到assert时才会进行判断并向stderr 中输出，static_assert静态断言是在编译时期进行断言的，所以说断言的需要的条件必须是编译时期可以确定的(constexpr 类型变量) static_assert ( bool_constexpr , message ) 性能方面，由于是static_assert编译期间断言，不生成目标代码，因此static_assert不会造成任何运行期性能损失。 #include\u003ciostream\u003e #include\u003cstring\u003e#include\u003climits\u003e int main(){ static_assert(!std::is_arithmetic\u003cint\u003e::value, \"only supports arithmetic types\"); } 编译报错，输出如下: main.cpp(7): error C2338: only supports arithmetic types ninja: build stopped: subcommand failed. static_assert有两个参数，第二个参数message可以用来打印错误提示，如果不想打印错误提示呢？在C++17之前，只能把第二个参数置为空字符串，C++17开始，message参数成为可选项，可以只填第一个参数。 static_assert(!std::is_arithmetic\u003cint\u003e::value); ","date":"2021-03-15","objectID":"/c-11%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80static_assert/:2:0","tags":["C++"],"title":"C++中的断言(assert与static_assert)","uri":"/c-11%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80static_assert/"},{"categories":["驱动"],"content":"windows上的新版驱动签名 前言 最近公司在进行网卡驱动的研发，而Windows驱动要想跑起来就必须得进行驱动签名。这中间过程坎坷，我们也在驱动签名上也踩过不少坑，特此记录，希望能帮到有需要的友商。 代码签名基础 在开始讲驱动签名之前，我们先简单的科普一下什么是代码签名。 ","date":"2021-02-20","objectID":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/:0:0","tags":["驱动"],"title":"windows驱动签名","uri":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/"},{"categories":["驱动"],"content":"什么是代码签名 代码签名（Code signing）是利用代码签名证书对可执行文件或脚本进行数字签名，以确认软件作者及保证软件在签名后未被修改或损坏的措施，此措施使用加密散列来验证真实性和完整性。简单来说就是进行代码签名后，可以增加程序的可信度。 ","date":"2021-02-20","objectID":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/:1:0","tags":["驱动"],"title":"windows驱动签名","uri":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/"},{"categories":["驱动"],"content":"代码签名证书分类 代码签名证书主要分为两类： 标准代码签名证书 标准代码签名(OV)只需要验证申请企业的基本信息、税务信息，验证成功后通过邮件等形式通常针对32/64位应用程序进行签名，以防止各类杀毒软件的误报。仅需较短的处理时间及较低的成本，但无法用于 LSA 和 UEFI 文件签名、无法用于内核模式驱动程序。 EV扩展型代码签名证书 EV扩展型代码签名证书除了验证企业的基本信息、税务信息外，还会对企业的经营地址、申请人身份进行审查，区别于标准代码签名的重要特点是支持Windows 10内核驱动文件签名和消除SmartScreen筛选器安全提醒，此外EV代码签名针对内核模式的驱动文件需要进行微软的交叉签名。 这里需要注意，驱动文件要用EV证书进行签名才可以用。 ","date":"2021-02-20","objectID":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/:2:0","tags":["驱动"],"title":"windows驱动签名","uri":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/"},{"categories":["驱动"],"content":"Windows驱动程序 了解了代码签名之后，再来了解一点关于Windows驱动程序的基础知识： Windows驱动程序是一种 位于内核地址空间 并且 工作于内核模式 的一种特殊的程序类型( .sys 文件 )； 驱动程序是操作系统信任的一个 内核扩展模块 ； 由于驱动程序是工作在内核，极其容易导致系统崩溃蓝屏，所以开发流程相对于普通应用程序会复杂一些； 驱动程序类似于DLL程序，它是一个回调函数(子程序)的集合体，这些函数由OS在适当的时候调用； 驱动程序也可以通过 Windows 内核 API 获得OS的一些服务。 驱动签名踩坑过程 微软提供的驱动签名有两种方式： 使用证明签名，仅适用于win10 使用HLK进行认证，适用于win7+win10 ","date":"2021-02-20","objectID":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/:3:0","tags":["驱动"],"title":"windows驱动签名","uri":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/"},{"categories":["驱动"],"content":"前置条件 开始之前进行驱动签名的准备工作，首先需要购买EV证书(我司在ssl.com进行购买)，然后登录到managecertificates，以开发者身份将提前准备好的EV证书提交到微软开发者进行认证。 具体步骤如下： 在微软开发者账户设置中选择管理证书 添加证书 下载SignableFile.bin 对SignableFile.bin进行签名，比如是在ssl.com买的EV证书，可以使用yubikey+signtool 本地签名，也可以使用 eSigner进行远程上签名 重新上传签完名的SignableFile.bin到微软上，没问题的话证书管理中会有新增的EV证书 提交完即可根据自身需求，自由选择签名方式。 ","date":"2021-02-20","objectID":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/:3:1","tags":["驱动"],"title":"windows驱动签名","uri":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/"},{"categories":["驱动"],"content":"一、使用证明签名(attestation-signing) PS： 证明签名(attestation-signing) 在Win 7上没法使用，已经尝试的签名组合： - Ev sha1+ Ev sha256(交叉签名) + 微软签名 - Ev sha1+ 微软签名 - Ev sha256 + 微软签名 根据微软文档 get-drivers-signed-by-microsoft-for-multiple-windows-versions，需提交Hardware Lab Kit (HLK) 微软硬件测试结果到微软测试上。也就是说如果想在Win7上使用，请用HLK，此处已踩坑。 ","date":"2021-02-20","objectID":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/:4:0","tags":["驱动"],"title":"windows驱动签名","uri":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/"},{"categories":["驱动"],"content":"创建CAB文件进行提交 此处不包含驱动开发部分，假设已经编译出驱动release，此时需要的打包文件有： 相关驱动文件 nacndislwf.cat NacNdisLwf.inf NacNdisLwf.sys 需使用MakeCab对驱动程序进行打包，相关makeCab程序及signtool请下载WindowsSDK包 创建DDF文件(相当于打CAB包的配置文件) ，下面是一个打包NacNdisLwf驱动的示例： ;*** nacndislwf.ddf example ; .OPTION EXPLICIT ; Generate errors .Set CabinetFileCountThreshold=0 .Set FolderFileCountThreshold=0 .Set FolderSizeThreshold=0 .Set MaxCabinetSize=0 .Set MaxDiskFileCount=0 .Set MaxDiskSize=0 .Set CompressionType=MSZIP .Set Cabinet=on .Set Compress=on ;Specify file name for new cab file .Set CabinetNameTemplate=NacNdisLwf.cab ; Specify the subdirectory for the files. ; Your cab file should not have files at the root level, ; and each driver package must be in a separate subfolder. .Set DestinationDir=NacNdisLwf ;Specify files to be included in cab file C:\\tmp\\Driver\\none\\NacNdisLwf.Inf C:\\tmp\\Driver\\none\\NacNdisLwf.Sys C:\\tmp\\Driver\\none\\nacndislwf.cat 打包前可以先对.cat .sys进行签名，这样签名下来可以有两个证书：一个我们的EV证书、一个微软的证明签名 signtool sign /as /fd sha256 /sha1 a32e4ea1143e9748389b2f3eb85e496d481ffbeb /tr http://ts.ssl.com \"C:\\tmp\\Driver\\double\\NacNdisLwf.sys\" signtool sign /as /fd sha256 /sha1 a32e4ea1143e9748389b2f3eb85e496d481ffbeb /tr http://ts.ssl.com \"C:\\tmp\\Driver\\double\\nacndislwf.cat\" 调用MakeCab进行打包 (路径需要自己指定) MakeCab /f \"C:\\tmp\\Driver\\DDF\\NacNdisLwfWin10.ddf\" 提交微软的全部文件必须进行EV/sha256签名 signtool sign /fd sha256 /sha1 a32e4ea1143e9748389b2f3eb85e496d481ffbeb /tr http://ts.ssl.com \"C:\\tmp\\Driver\\DDF\\disk1\\NacNdisLwf.cab\" 提交微软测试 dashboard/hardware/Search 选择Submit new hardware 提交签名过后的CAB文件，等待微软验证，相关错误会反馈回来；若签名无问题，即可下载已签名完成的文件 查看结果，可见已经有了微软给的驱动签名 具体步骤，请参考官方文档微软签名：attestation-signing-a-kernel-driver-for-public-release ","date":"2021-02-20","objectID":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/:4:1","tags":["驱动"],"title":"windows驱动签名","uri":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/"},{"categories":["驱动"],"content":"二、使用HLK签名认证 ","date":"2021-02-20","objectID":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/:5:0","tags":["驱动"],"title":"windows驱动签名","uri":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/"},{"categories":["驱动"],"content":"搭建HLK测试环境 PS：具体请参考微软文档： windows-hardware 大致逻辑是，需要搭建HLK server与HLK client，将需要测试的驱动程序部署在HLK client上，在HLK server进行控制，HLKserver会对Client执行各种自动化操作，并在server上生成测试结果。 在测试服务器上安装 Controller 和 Studio 去微软下载对应系统版本的安装包 windows-hardware/test/hlk/ ，包名为HLKSetUp.exe，先下载所需要的库及相关资料，下载后进行统一安装 在Client上安装HLK客户端 确保与server处于同一个局域网域下，ControllerName为server端的设备名注意此处不要使用Ip，已踩过坑 \\\\\u003cControllerName\u003e\\HLKInstall\\Client\\Setup.cmd 另外还有个坑：Client系统语言请使用英语，不然会出现各种奇奇怪怪的报错 创建机器池 客户端安装完成后会打开HLK Studio，点击Configuration可以看到刚刚安装客户端的设备机器 需新建一个机器池，并将这个设备从默认的机器池中拖出去，然后右键更改状态为ready 之后便可以新建项目，选择测试目标Client上已经安装的驱动进行测试了，这块没啥坑，直接看微软文档即可 选择Client上的驱动 (先在Client上安装自己的驱动，studio这边刷新之后就会显示) 在Tests上勾选需要运行的自动测试，点击Run selected进行自动测试 查看测试结果，遇到失败可以查看原因解决 创建提交包：驱动通过验证后需创建提交包进行提交 点击add Driver Folder 选择提交的驱动相关文件 nacndislwf.cat NacNdisLwf.inf NacNdisLwf.sys 点击CreatPackage 进行创建包 签名 微软是推荐使用Use the certificate store里面的证书，但我们在插入yubikey打算使用usb密钥的证书对他进行签名时，发现可以选择在yubikey中的证书。但签名时会失败，报错为Unable to use the selected certificate to sign the package ，进入到Event viewer中查看详情为：Unable to use the selected certificate to sign the package 研究了很久，在创建HLKX时只能在这里选择签名，因为HLK不支持signtools 解决方案1：使用C#的CSP对HLkx进行签名 ，\u003c失败：CSP无法识别sha384 签名\u003e 解决方案2 ：问SSL.com客服询问解决方法，客服联系相关技术人员回复邮件，结果迟迟未回复 在相关社区找到资料，看起来是HLK studio只支持sha256签名，不支持新的sha384签名 指路：for-a-windows-10-submission-the-input-package-and-the-included-files-must-be-signed-with-sha256-sig#latest 通过SSL.com签发的OV证书进行签名 由于之前SSl.com的OV代码证书没有人在使用，所以需要重新创建CSR提交到SSL上重新生成证书(SSL.com的验证流程很慢，正常要3-5天) 获取SSL.com带私钥的OV证书 查看OV证书是不是带sha256 RSA类型 与EV证书采用相同的操作(下载SignableFile.bin本地使用SignTool签名后，上传到微软开发者验证) 在Use the certificate store中选择导入本机OV证书 签名成功 提交微软认证 签名问题小结：签名会失败的原因由于EV证书的签名算法为Sha384ECDSA，HLK Studio不支持认证该算法，只能使用SHA256RSA来解决；只使用HLK认证的签名依然会失败，这是由于Win10以下的驱动使用HCK认证(与HLK一样 HLK是其升级版本)，可以在创建HLK提交后在Package页面选择merge package将HCK数据包合并到HLK中才可以认证Win7。 ","date":"2021-02-20","objectID":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/:5:1","tags":["驱动"],"title":"windows驱动签名","uri":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/"},{"categories":["驱动"],"content":"HCK 环境搭建 可参考文档： windows-hardware-certification-kit 大致安装流程与HLK认证基本相同，这里分享一下过程中踩过的坑： HCKserver版本可以使用server2012及server2008，建议使用2008英文版 - 原因：server2012默认开启domin contrller会导致安装失败，且这个domin contrller不是很好关闭 需要关闭IE ESC配置 - 不关闭IE ESC 安装，.net 4.5会失败(点击service manager关闭IE ESC) server与client请都使用英文版，避免不必要的问题 安装后，操作流程与HLK一致，最后package需注意： 不需要签名，直接生成不签名的HCKX文件 生成后发送hckx文件到HLK server上进行merge package操作 ","date":"2021-02-20","objectID":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/:5:2","tags":["驱动"],"title":"windows驱动签名","uri":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/"},{"categories":["驱动"],"content":"经验教训 建议使用微软的VHLK虚拟机，在本地装hyper-v直接使用虚拟机运行server可以省很多事情 HLK Client版本请选择对应VHLK虚拟机的版本， windows-hardware/test/hlk/ 上有对应版本的相关说明 当HLKserver环境内没有相关证书时，可以先生成无签名的hlkx，在外部有证书的机器上下载HLK studio(此时不需要下载contrler)，使用HLK studio打开hlkx重新创建包，并且选择签名重新生成带有签名的hlkx 使用英文版！使用英文版！使用英文版！重要的事情说三遍 ","date":"2021-02-20","objectID":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/:6:0","tags":["驱动"],"title":"windows驱动签名","uri":"/%E9%A9%B1%E5%8A%A8%E7%AD%BE%E5%90%8D%E8%B8%A9%E5%9D%91/"},{"categories":["C++"],"content":"decltype类型推导 decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 typeof 很相似： decltype(表达式) 有时候，我们可能需要计算某个表达式的类型，例如： auto x = 1; auto y = 2; decltype(x+y) z; int i=10; decltype(i) a; //a推导为int decltype((i))b=i;//b推导为int\u0026，必须为其初始化，否则编译错误 前面的例子 decltype 用于推断类型的用法，下面这个例子就是判断上面的变量 x, y, z 是否是同一类型： if (std::is_same\u003cdecltype(x), int\u003e::value) std::cout \u003c\u003c \"type x == int\" \u003c\u003c std::endl; if (std::is_same\u003cdecltype(x), float\u003e::value) std::cout \u003c\u003c \"type x == float\" \u003c\u003c std::endl; if (std::is_same\u003cdecltype(x), decltype(z)\u003e::value) std::cout \u003c\u003c \"type z == type x\" \u003c\u003c std::endl; 其中，std::is_same\u003cT, U\u003e 用于判断 T 和 U 这两个类型是否相等。输出结果为： type x == int type z == type x ","date":"2021-02-18","objectID":"/decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:0:0","tags":["C++"],"title":"decltype类型推导","uri":"/decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["C++"],"content":"decltpe在尾返回类型(trailing return type)中的使用 传统c++中 实现一个模板加法函数 template\u003ctypename R, typename T, typename U\u003e R add(T x, U y) { return x+y; } typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。但在模板中定义有嵌套依赖类型的变量时，需要用 typename 消除歧义 这样的代码其实变得很丑陋，因为在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 add() 这个函数会做什么样的操作，以及获得一个什么样的返回类型。 在 C++11 中这个问题得到解决。虽然你可能马上会反应出来使用 decltype 推导 x+y 的类型，写出这样的代码： decltype(x+y) add(T x, U y) 但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y尚未被定义。为了解决这个问题，C++11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键字将返回类型后置： template\u003ctypename T, typename U\u003e auto add2(T x, U y) -\u003e decltype(x+y){ return x + y; } 是从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法： template\u003ctypename T, typename U\u003e auto add3(T x, U y){ return x + y; } 可以检查一下类型推导是否正确： // after c++11 auto w = add2\u003cint, double\u003e(1, 2.0); if (std::is_same\u003cdecltype(w), double\u003e::value) { std::cout \u003c\u003c \"w is double: \"; } std::cout \u003c\u003c w \u003c\u003c std::endl; // after c++14 auto q = add3\u003cdouble, int\u003e(1.0, 2); std::cout \u003c\u003c \"q: \" \u003c\u003c q \u003c\u003c std::endl; decltype(auto) decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。 当decltype(auto)被用于声明变量时，该变量必须立即初始化。假设该变量的初始化表达式为e，那么该变量的类型将被推导为decltype(e)。也就是说本质是在推导变量类型时，先用初始化表达式替换decltype(auto)当中的auto，然后再根据decltype的语法规则来确定变量的类型。 在 C++11 中，封装实现是如下形式： std::string look_up_a_string_1() { return lookup1(); } std::string\u0026 look_up_a_string_2() { return lookup2(); } 而有了 decltype(auto)，可以让编译器完成这一件烦人的参数转发： decltype(auto) look_up_a_string_1() { return lookup1(); } decltype(auto) look_up_a_string_2() { return lookup2(); } ","date":"2021-02-18","objectID":"/decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/:1:0","tags":["C++"],"title":"decltype类型推导","uri":"/decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"categories":["C++"],"content":"const详解 ","date":"2020-12-18","objectID":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/:0:0","tags":["C++"],"title":"Const详解与constexpr","uri":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/"},{"categories":["C++"],"content":"简介 C++中的Const作为从C中继承下来的关键字，名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。 ","date":"2020-12-18","objectID":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/:1:0","tags":["C++"],"title":"Const详解与constexpr","uri":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/"},{"categories":["C++"],"content":"const 基本修饰 C语言中的const仅能维持编译期的值不变性，但是运行时值依然是可变的： int main(int argc, char *argv) { const int a = 0; // a = 10; // (编译期的const保持)编译错误，因为试图修改一个常量。 // (运行时const属性失效) int *pa = (int *)\u0026a; *pa = 20; // 正确，此时a的值被修改为20，失去常量属性。 return 0; } 由于a = 10编译时会报错，所以编译时屏蔽，运行结果： 可以看到 C中的const只能在编译过程中保持数据不变，还是会被指针修改 为了维持运行时的const语义，c++引入了常量表来记录const对象的名称和值，并将之后所有对const对象的访问修改为访问常量表中的值，以此保证const对象始终如一的常量属性。同时为了保持向下兼容C，C++采取另外一种常量对象的内存分配方式，即： 代码中的const常量并不会立刻分配内存，只有当需要该对象的地址时，才为其分配内存，但从不使用该内存。 同样的代码，让我们使用C++编译器编译 接下来分析编译过程 int main(int argc, char *argv) { const int a = 0; // a成为常量，\u003ca, 0\u003e被保存进入了常量区中，但是并未在栈上为a分配内存。 a = 10; // 编译错误，因为试图修改一个常量。 int *pa = (int *)\u0026a; // 此时，需要常量a的地址，因此编译器被迫在栈上为a分配一块内存。 *pa = 20; // 此时，编译器被迫为a分配的内存被写为20，但是编译器不会使用这块内存。 printf(\"a = %d\\n\", a); // 但是，每次对a的访问都会去访问常量表，因此a仍然为0，保持了常量属性。 return 0; } 然而，并非所有的常量值都能在编译期被确定。当只有在运行时才能确定常量的值时，该常量将不会进入常量区，仍然保持C语言的运行时不安全的常量属性： int situation1() { int v = 0; const int a = v; // 编译期间无法确定a的值，因此a不会进入常量区。 a = 10; // 编译错误，因为试图修改一个常量。 int *pa = (int *)\u0026a; // 取得了真正a变量的地址。 *pa = 20; // 此时a的值被修改为20，失去常量属性。 return 0; } int situation2() { const volatile int a = 0; // 编译期间无法确定a的值，因此a不会进入常量区。 a = 10; // 编译错误，因为试图修改一个常量。 int *pa = (int *)\u0026a; // 取得了真正a变量的地址。 *pa = 20; // 此时a的值被修改为20，失去常量属性。 return 0; } 如果赋值号两边的数据类型不同，那么将会产生类型截断，此时const也会失去常量语义： int situation3() { const long a = 0; // a成为常量，\u003ca, 0\u003e被保存进入了常量区中，但是并未在栈上为a分配内存。 const int b = a; // 发生了类型截断，因此即便编译期可以确定值，也不会进入常量表。 int *pb = (int *)\u0026b; // 取得了真正a变量的地址。 *pb = 20; // 此时b的值被修改为20，失去常量属性。 return 0; } ","date":"2020-12-18","objectID":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/:2:0","tags":["C++"],"title":"Const详解与constexpr","uri":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/"},{"categories":["C++"],"content":"const修饰指针 const用于指针时，其行为和C语言中基本一致。例如，顶层const表示指针不能再指向其它地址，底层const保证目前指向的地址中的数据不可被修改： int main(int argc, char *argv[]) { const int *a = nullptr; // 底层const，表示地址中的数据不可被修改(修饰指针指向的地址) int *const b = nullptr; // 顶层const，表示指针不能指向其它位置。(修饰指针变量) const int *const c = nullptr; // 顶层和底层const，表示指针不能指向其它位置， // 并且地址中的数据不可被修改。(修饰指针指向的地址与指针变量) return 0; } ","date":"2020-12-18","objectID":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/:3:0","tags":["C++"],"title":"Const详解与constexpr","uri":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/"},{"categories":["C++"],"content":"const修饰引用 const引用没有顶层和底层之分，所有的const引用都是底层的。当针对左值引用使用const时，其行为如同C语言中的const一样，会产生一个新的编译期常量： int main(int argc, char *argv[]) { const int \u0026a = 0; a = 10; // 编译错误，因为试图修改一个常量。 int *pa = (int *)\u0026a; *pa = 20; // 正确，a的值被修改为20. return 0; } 右值不能绑定到左值引用上，但是可以绑定到常量左值引用上，这是因为它可以保证部分右值的不可修改属性。同理，从语义上来看，没有必要使用const修饰右值引用。 ","date":"2020-12-18","objectID":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/:4:0","tags":["C++"],"title":"Const详解与constexpr","uri":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/"},{"categories":["C++"],"content":"const修饰函数 在类的方法声明中使用const，则表示这个方法不会导致当前对象的改变；同时，为了保持对象的常量属性，const对象只能调用const方法。 class Object { int _value; public: Object(int value) : _value(value) {} int get_value() const { return _value; } void set_value(int value) { _value = value; } }; int main(int argc, char *argv[]) { Object o1(10); o1.get_value(); // 正确, 10 o1.set_value(20); // 正确 const Object o2(10); o2.get_value(); // 正确, 10 o2.set_value(20); // 错误，const对象只能调用const方法。 return 0; } ","date":"2020-12-18","objectID":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/:5:0","tags":["C++"],"title":"Const详解与constexpr","uri":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/"},{"categories":["C++"],"content":"C++11 constexpr（常量表达式） C++11引进了constexpr函数，目的是将运算尽量放在编译阶段，而不是运行阶段。const 变量的初始化可以延迟到运行时(见上文)，而 constexpr 变量必须在编译时进行初始化。 所有constexpr对象都是const的，但是不是所有的const对象都是constexpr的。 事实上const并不能代表“常量”，它仅仅是对变量的一个修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过堆栈溢出等方式修改）。而这个变量的值，可以在运行时也可以在编译时指定 int a3 = 5; // a3不是常量表达式 constexpr int a4 = a3; // a4不是常量表达式，因为a3程序的执行到达其所在的声明处时才初始化 ","date":"2020-12-18","objectID":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/:6:0","tags":["C++"],"title":"Const详解与constexpr","uri":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/"},{"categories":["C++"],"content":"constexpr修饰函数 constexpr函数是指能用于常量表达式的函数。 函数的返回类型以及所有形参的类型都得是字面值类型 函数体中必须有且仅有一条return语句 constexpr int lab(int i) { return i*10; } int main() { int i ; constexpr int a = lab(i); // Error the value of 'i' is not usable in a constant expression (i不是一个字面值类型) constexpr int b = lab(10);//Success 形参为非字面值类型,但是实参为字面值类型，编译器会对其优化 return 0; } 同时，执行上述函数时，编译器会对constexpr函数的调用替换成其结果值，为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。既然内联函数，我们就需要遵守内联函数的规则即将 constexpr函数定义在头文件中 ","date":"2020-12-18","objectID":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/:6:1","tags":["C++"],"title":"Const详解与constexpr","uri":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/"},{"categories":["C++"],"content":"constexpr 修饰构造函数 尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。 字面值常量类 数据成员都是字面值类型的聚合类是字面值常量类，例如 struct Person { std::string name; int height; }; 聚合类条件： 所有成员都是public 没有定义构造函数 没有类内初始值 没有基类，也没有虚函数 如果一个类不是聚合类，成为一个字面值常量类符合的要求： 数据成员都必须是字面值类型。 类必须至少含有一个 constexpr 构造函数。 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式。或者如果成员属于某种类类型，则初始值必须使用成员自己的 constexpr 构造函数。 类必须使用析构函数的默认定义，该成员负责销毁对象。 示例类： class Debug { private: bool hw; bool io; bool other; public: constexpr Debug(bool b = true) :hw(b), io(b), other(b) {} constexpr Debug(bool h, bool i, bool o) : hw(h), io(i), other(o) {} constexpr bool any()const { return hw || io || other; } void set_io(bool b) { io = b; } void set_hw(bool b) { hw = b; } void set_other(bool b) { other = b; } }; int main() { constexpr Debug io_sub(false, true, false); //调试IO if (io_sub.any()) //等价于if(true) cerr \u003c\u003c \"print appropriate error messages\" \u003c\u003c endl; constexpr Debug prod(false); //无调试 if (prod.any()) //等价于if(false) cerr \u003c\u003c \"print an error message\" \u003c\u003c endl; return 0; } 字面值常量类与字面值类型的用法相同，字面值常量类同样也会在编译期进行计算。 ","date":"2020-12-18","objectID":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/:6:2","tags":["C++"],"title":"Const详解与constexpr","uri":"/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/"},{"categories":["Qt"],"content":"[TOC] 1. 基本操作 ","date":"2020-12-07","objectID":"/qt%E6%93%8D%E4%BD%9Cmysql/:0:0","tags":["Qt"],"title":"Ｑｔ操作mysql","uri":"/qt%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Qt"],"content":"1.1 添加模块 Qt数据库模块是独立模块，需要像core，gui一样在.pro文件中添加该模块 QT+=sql 1.2 基本操作 ","date":"2020-12-07","objectID":"/qt%E6%93%8D%E4%BD%9Cmysql/:1:0","tags":["Qt"],"title":"Ｑｔ操作mysql","uri":"/qt%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Qt"],"content":"获取可用连接 首先查看qt下支持的连接名 qDebug() \u003c\u003c QSqlDatabase::drivers(); 输出如下 (\"QSQLITE\", \"QMYSQL\", \"QMYSQL3\", \"QPSQL\", \"QPSQL7\") ","date":"2020-12-07","objectID":"/qt%E6%93%8D%E4%BD%9Cmysql/:2:0","tags":["Qt"],"title":"Ｑｔ操作mysql","uri":"/qt%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Qt"],"content":"建立连接 使用上一步获取到的连接名作为addDatabase的第一个参数 QSqlDatabase db = QSqlDatabase::addDatabase(\"QMYSQL\"); 这样我们就获取到mysql的句柄了 接下来是mysql的基本操作 db.setHostName(\"localhost\"); // 假定数据库在本机 db.setDatabaseName(\"student\"); // 打开数据库名 db.setUserName(\"root\"); // 数据库用户名 db.setPassword(\"123456\"); // 数据库密码 设置完之后调用open()打开mysql数据库,完整代码如下 QSqlDatabase db = QSqlDatabase::addDatabase(\"QMYSQL\"); db.setHostName(\"localhost\"); // 假定数据库在本机 db.setDatabaseName(\"server\"); // 打开数据库名 db.setUserName(\"root\"); // 数据库用户名 db.setPassword(\"123456\"); // 数据库密码 if (!db.open()) { qDebug() \u003c\u003c \"Failed to connect to root mysql!\"; } else { qDebug() \u003c\u003c \"open success!\"; } ","date":"2020-12-07","objectID":"/qt%E6%93%8D%E4%BD%9Cmysql/:3:0","tags":["Qt"],"title":"Ｑｔ操作mysql","uri":"/qt%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Qt"],"content":"增删改查 数据库操作无非增删改查，基于我们获取到的句柄，我们可以对数据库进行操作。 QSqlQuery类提供了一种执行和操作SQL语句的方法 QSqlQuery sqlquery(db); 插入数据Demo //插入新数据 QSqlQuery sql_query(db); sql_query.prepare(\"insert into stu(name,stuID,sex,score) values('stu2','123123','1',''70)\"); if(!sql_query.exec()) { qDebug()\u003c\u003csql_query.lastError(); } else { qDebug()\u003c\u003c\"insert Success...\"; } 查询Demo QSqlQuery sql_query(db); sql_query.prepare(\"select * from stu\"); if(!sql_query.exec()) { qDebug()\u003c\u003csql_query.lastError(); } else { while(sql_query.next()) { QString name = sql_query.value(\"name\").toString(); QString id = sql_query.value(\"stuID\").toString(); QString sex = sql_query.value(\"sex\").toString(); QString score = sql_query.value(\"score\").toString(); qDebug()\u003c\u003cQString(\"Name:%1 ID:%2 sex:%3 score:%4\").arg(name).arg(id).arg(sex).arg(score); } } 1.3 批量使用 2. driver not loaded错误处理 ","date":"2020-12-07","objectID":"/qt%E6%93%8D%E4%BD%9Cmysql/:4:0","tags":["Qt"],"title":"Ｑｔ操作mysql","uri":"/qt%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Qt"],"content":"问题排查 第一次使用Qtmysql的库时容易看到qDebug有如下打印 QSqlDatabase: QMYSQL driver not loaded QSqlDatabase: available drivers: QSQLITE QMYSQL QMYSQL3 QPSQL QPSQL7 查看本机mysql，发现mysqlClient库安装正常 ls /usr/lib/x86_64-linux-gnu/libmysql* -lsd 查看Qt数据组件sql是否正常 1）进入到Qt的安装目录下，进入对应编译器文件夹中，楼主的文件夹是 查看**libqsqlmysql.so**文件链接是否正常 ldd libqsqlmysql.so 结果发现Qt中mysql库链接的是18的版本，而当前环境没有该版本的mysql库 ","date":"2020-12-07","objectID":"/qt%E6%93%8D%E4%BD%9Cmysql/:5:0","tags":["Qt"],"title":"Ｑｔ操作mysql","uri":"/qt%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Qt"],"content":"解决方案 ","date":"2020-12-07","objectID":"/qt%E6%93%8D%E4%BD%9Cmysql/:6:0","tags":["Qt"],"title":"Ｑｔ操作mysql","uri":"/qt%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Qt"],"content":"1.下载对应版本的libsqlclient 这个方式比较方便，适合绝大多数场景 下载地址： https://launchpad.net/ubuntu/xenial/amd64/libmysqlclient18/5.6.25-0ubuntu1 下载 libmysqlclient18_5.6.25-0ubuntu1_amd64.deb，然后 dpkg -i libmysqlclient18_5.6.25-0ubuntu1_amd64.deb 即可。 ","date":"2020-12-07","objectID":"/qt%E6%93%8D%E4%BD%9Cmysql/:6:1","tags":["Qt"],"title":"Ｑｔ操作mysql","uri":"/qt%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Qt"],"content":"2.重新编译Qt中的libqsqlmysql库 进入安装时下载的Qt源码，在对应版本的SRC文件夹下，对该库的源码进行重新编译 最后将编译好的libqsqlmysql.so库放回原先的位置。 ","date":"2020-12-07","objectID":"/qt%E6%93%8D%E4%BD%9Cmysql/:6:2","tags":["Qt"],"title":"Ｑｔ操作mysql","uri":"/qt%E6%93%8D%E4%BD%9Cmysql/"},{"categories":["Http"],"content":"libCurl编译 1.首先下载libCurl的源码，这里使用的是Github上的版本 git clone https://github.com/curl/curl.git 或者 git clone https://github.com/curl/curl 2.生成configure ./buildconf 3.查看本地可开启的功能 ./configure --enable-pthreads 会显示默认环境下安装后能使用的功能，若是满足需求就直接make和sudo make install 若要开启SSL support和zlib support:(Centos) yum install openssl-libs openssl-devel 若要支持https需安装libssh2:(Centos) yum install libssh2-devel 若要支持PSL 验证 Cookie 和证书的 Domain 信息，则安装libpsl:(Centos) yum psl libpsl-devel 若要支持HTTP2 ,则安装nghttp2:(Centos) yum install libnghttp2-devel nghttp2 若要支持IDN,则安装libidn:(Centos) yum install libidn2 libidn2-devel 若要支持metalink，则安装 libmetalink:(Centos) yum install libmetalink libmetalink-devel 若要支持RTMP实时流传输，则到官网下载安装,可以参考文章 linux下编译支持librtmp、libx264、libfaac的ffmpeg Ubuntu的可对应上面的centos库自行百度下载 4.编译libcurl 由于本人需要openssl 与SSH2的功能（从上图可以看到SSH为未链接状态，我们可以下载libssh2进行编译） 编译OpenssH（可选） wget http://www.libssh2.org/download/libssh2-1.4.3.tar.gz tar -zxvf libssh2-1.4.3.tar.gz cd libssh2-1.4.3/ //由于我/usr/local的openssl版本太高了，编译会报错，所以使用低版本的openssl ./configure --prefix=/usr/local/libssh2 --with-openssl CPPFLAGS=\"-I/usr/local/openssl/include\" LDFLAGS=\"-L/usr/local/openssl/lib\" make make insatll 将openssh与openssl链接到libcurl中 进入libcurl文件夹 ./configure --prefix=/home/lin/libcurl/outputFile --enable-debug --with-openssl CPPFLAGS=\"-I/home/lin/openssl/include\" LDFLAGS=\"-L/home/lin/openssl/lib\" --with-libssh2 CPPFLAGS=\"-I/usr/local/libssh2/include\" LDFLAGS=\"-L//usr/local/libssh2/lib\" 可以看到openssh的功能已经支持。 需要其他的功能也是同理，这里就不展开讲了。 5.编译与安装 接下来就是make与makeinstall了 make -j4 make install 查看设置输出的outputFile文件夹，已经编译成功 ","date":"2020-12-05","objectID":"/libcurl%E7%BC%96%E8%AF%91/:0:0","tags":["Http"],"title":"LibCurl编译","uri":"/libcurl%E7%BC%96%E8%AF%91/"},{"categories":["NDK"],"content":"编译android对应版本的openssl ","date":"2020-11-05","objectID":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/:0:0","tags":["NDK"],"title":"编译android对应版本的openssl","uri":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/"},{"categories":["NDK"],"content":"版本 自行下载需要的NDK与openssl NDK: android-ndk-r15c openssl：openssl-1.0.2 ","date":"2020-11-05","objectID":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/:1:0","tags":["NDK"],"title":"编译android对应版本的openssl","uri":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/"},{"categories":["NDK"],"content":"下载交叉编译文件 #拉取setenv-android.sh，我们需要这个脚本来给我们配置环境 wget https://wiki.openssl.org/images/7/70/Setenv-android.sh ","date":"2020-11-05","objectID":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/:2:0","tags":["NDK"],"title":"编译android对应版本的openssl","uri":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/"},{"categories":["NDK"],"content":"配置脚本 ","date":"2020-11-05","objectID":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/:3:0","tags":["NDK"],"title":"编译android对应版本的openssl","uri":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/"},{"categories":["NDK"],"content":"armv7a版本配置 _ANDROID_NDK=\"android-ndk-r9\" # 修改为： _ANDROID_NDK=\"android-ndk-r15c\" # 因为我们使用的是R14B这个版本的NDK _ANDROID_EABI=\"arm-linux-androideabi-4.8\" 修改为GCC 4.9 _ANDROID_EABI=\"arm-linux-androideabi-4.9\" ### arm64V8A版本配置 _ANDROID_NDK=\"android-ndk-r9\" # 修改为： _ANDROID_NDK=\"android-ndk-r15c\" # 因为我们使用的是r15c这个版本的NDK _ANDROID_EABI=\"arm-linux-androideabi-4.8\" 修改为GCC 4.9 _ANDROID_EABI=\"aarch64-linux-android-4.9\" _ANDROID_ARCH=arch-arm 修改为 _ANDROID_ARCH=arch-arm64 ","date":"2020-11-05","objectID":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/:3:1","tags":["NDK"],"title":"编译android对应版本的openssl","uri":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/"},{"categories":["NDK"],"content":"编译 添加环境变量（仅在当前终端就可以了 export ANDROID_NDK_ROOT=/home/ubuntu/android-ndk-r15c source ./Setenv-android.sh FIPS_SIG的Error无所谓，本次不会使用到这个组件 ","date":"2020-11-05","objectID":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/:4:0","tags":["NDK"],"title":"编译android对应版本的openssl","uri":"/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/"},{"categories":["Docker"],"content":"opencv视频流处理方法 OpenCV提供了VideoCapture类和VideoWriter类来支持各种格式的视频流，支持的格式类型会因系统的不同而有所变化，但基本上都是支持avi格式的，且对于视频文件和摄像头画面的读写所用到的接口基本上都相同，因此，我们把它们放在一起来讲了。 1. 获取VideoCapture类实例 不管是读取视频文件还是捕获摄像头画面，都使用到了VideoCapture类，但不同的是传入的形参不一样，如果我们传给VideoCapture类的是一个视频文件路径那么将是读取来自视频文件的画面，而如果我们传给VideoCapture类的是摄像头编号那么将是读取来自摄像头的画面，其使用示例如下： # 获取VideoCapture类实例，读取视频文件 fcap = cv2.VideoCapture('demo.mp4') # 读取摄像头画面 ccap = cv2.VideoCapture(0) 对于摄像头编号，可以使用如下命令获取： ls -al /dev/ | grep video 对于输出信息以video开头的其数字后缀即为可能的摄像头编号，如果一台电脑有多个摄像头设备，那么将会出现从0开始的多个摄像头编号。 2. 判断获取VideoCapture实例是否成功 如果传入无效的视频文件或摄像头编号，那么VideoCapture类将会在后续的read()接口返回（False，None），为了避免此类事件发生，可以通过VideoCapture类的isOpened()接口进行判断，该接口返回一个boolean值，正常获取实例返回True，否则返回False，其使用示例如下： # 判断是否正确获取VideoCapture类实例 while fcap.isOpened(): # next step operation 3. 获取视频流信息 一般视频流主要的帧信息包含画面宽高还有帧率，对于视频文件，则会多出整个视频流多少帧，因此，我们一般主要关注这四个视频流信息即可，而我们用到的则是VideoCapture类的get接口，其使用示例如下： # 获取视频帧的宽 w = fcap.get(cv2.CAP_PROP_FRAME_WIDTH) # 获取视频帧的高 h = fcap.get(cv2.CAP_PROP_FRAME_HEIGHT) # 获取视频帧的帧率 fps = fcap.get(cv2.CAP_PROP_FPS) 获取到的帧率对于摄像头设备来说，如果所使用的终端不支持查询，那么将会返回0值，且该值也不是非常精确的。 # 获取视频流的总帧数 fcount = fcap.get(cv2.CAP_PROP_FRAME_COUNT) 注意这个是对视频文件才有意义，对于摄像头是没意义的，且以上获取到的返回信息均是浮点型的，注意转换为整型。 4. 获取帧画面 这个就相对简单，直接使用VideoCapture类的read接口即可，该接口会返回两个参数，第一个参数是读取成功与否标志位，成功为True否则为False，第二个参数则为具体的帧数据，其是一个numpy.ndarray的数组，其使用示例如下： # 获取帧画面 success, frame = fcap.read() 但在读取过程中，有可能会存在失败的情况出现，一般我们是在第二次读取时放入一个while循环来保障整个读取顺利进行，如下： # 判断读取视频流是否成功 while success: success, frame = fcap.read() # do something in here 5. 针对一组或多头摄像头特殊处理 当需要同步一组摄像头或一个多头（multihead）摄像头（例如立体摄像头或Kinect）时，read()方法就不太适用了，这时，一般使用grab()和retrieve()方法代替它。对于一组摄像头，其使用示例如下： # 一组摄像头的特殊处理 success0 = fcap0.grab() success1 = fcap1.grab() if success0 and success1: frame0 = fcap0.retrieve() frame1 = fcap1.retrieve() 6. 跳到视频流某一帧 对于视频文件，有时候我们需要直接跳到某一个感兴趣的帧并从该帧开始读取数据，那么可以使用VideoCapture类的set接口，其使用示例如下： # 跳到某一感兴趣帧并从此帧开始读取,如从第360帧开始读取 fcap.set(cv2.CAP_PROP_POS_FRAMES, 360) success, frame = fcap.read() 7. 设置摄像头分辨率 opencv读取到的摄像头画面大小一般为默认的640x480，但这并不一定满足我们的日常使用要求，比如摄像头支持超高清画面，那么我们就希望能捕获到超高清1920x1080的画面，好在VideoCapture类的set接口为我们提供了相应的功能，其使用示例如下： # 设置摄像头分辨率的高 fcap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080) # 设置摄像头分辨率的宽 fcap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920) 8. 获取VideoWriter类实例 不管是对视频文件的再存储还是对摄像头画面的保存，都是用到了VideoWriter类，且传入的形参意义是一致的，都需要我们传入保存的文件名包含视频格式、指定视频编解码器、保存视频的帧率以及保存视频的分辨率，一般来说，保存视频的帧率最好与读入的画面的帧率一致，但需要我们进行估计或使用计时器才会比较准确，而分辨率则可以更改，只是要求写入的帧其大小要与分辨率保持一致，其使用示例如下： writer = cv2.VideoWriter('output.avi', cv2.VideoWriter_fourcc('X', 'V', 'I', 'D'), 30, (1080, 1920)) 值得注意的是，我们必须要为VideoWriter类的构造函数传入所需的参数，且若指定的文件名已存在则会被直接覆盖。 9. VideoWriter类支持的视频编解码器 在构造VideoWriter类实例时，我们必须要指定视频编解码器，那么VideoWriter类都支持哪些视频编解码器呢？我们通过cv2.VideoWriter_fourcc来指定具体使用的编解码器： 'I','4','2','0'：该选项是一个未压缩的YUV颜色编码，兼容性好，但产生文件较大，文件扩展名为.avi 'P','T','M','I'：该选项是MPEG-1编码类型，文件扩展名为.avi 'X','V','T','D'：该选项是MPEG-4编码类型，得到的视频大小处于平均值，文件扩展名为.avi 'T','H','E','O'：该选项是Ogg Vorbis，文件扩展名为.ogv 'F','L','V','1'：该选项是一个flash视频，文件扩展名为.flv 一般常用的是cv2.VideoWriter_fourcc(‘X’,‘V’,‘T’,‘D’)，mp4编码文件相对小一些，或cv2.VideoWriter_fourcc(‘I’,‘4’,‘2’,‘0’)，文件相对大一些，但为了缩小文件空间我们可能还需要用到ffmpeg工具进一步压缩文件。 10. 保存帧数据 这个也很简单，直接使用VideoWriter类的write接口即可，该接口一次可以保存一帧数据到制定文件中，其使用示例如下： # 保存帧数据 writer.write(frame) 11. 释放资源 不管是VideoCapture类还是VideoWriter类，当我们使用完了它们之后，都应该将它们释放掉，避免资源一直被占用，而这两个类都有提供了release()接口给我们，我们只需直接调用即可释放资源，使用示例如下： # 释放VideoCapture资源 fcap.release() # 释放VideoWriter资源 writer.release() 12. 一个完整的示例代码 # -*- coding: utf-8 -*- # /usr/bin/env/python3 '''use opencv3 to capture video frame, show and save its stream.''' import cv2 def stream_processing(): # 获取VideoCapture类实例，读取视频文件 fcap = cv2.VideoCapture('demo.mp4') # 设置摄像头分辨率的高 fcap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080) # 设置摄像头分辨率的宽 fcap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920) # 跳到某一感兴趣帧并从此帧开始读取,如从第360帧开始读取 fcap.set(cv2.CAP_PROP_POS_FRAMES, 360) # 获取视频帧的宽 w = fcap.get(cv2.CAP_PROP_FRAME_WIDTH) # 获取视频帧的高 h = fcap.get(cv2.CAP_PROP_FRAME_HEIGHT) # 获取视频帧的帧率 fps = fcap.get(cv2.CAP_PROP_FPS) # 获取视频流的总帧数 fcount = fcap.get(cv2.CAP_PROP_FRAME_COUNT) # 获取VideoWriter类实例 writer ","date":"2020-10-15","objectID":"/opencv%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/:0:0","tags":["Docker"],"title":"Opencv视频流处理方法","uri":"/opencv%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"},{"categories":["音视频"],"content":"VLC编译 git clone git://github.com/vlc-qt/vlc-qt.git sudo apt install libvlc-dev sudo apt-get install snapd sudo apt-get install snapcraft sudo snap install vlc export QTDIR=/Qt安装路径/5.12.3/gcc_64 export LD_LIBRARY_PATH=$QTDIR/lib export PATH=$PATH:$QTDIR/bin sudo cmake .. -DCMAKE_BUILD_TYPE=Debug sudo make -j8 sudo make install core libvlc error: No plugins found! Check your VLC installation. VLC-Qt Error: libvlc failed to load! sudo apt-get install libvlc-dev sudo apt-get install vlc CMake Error at config/Dependencies.cmake:28 (FIND_PACKAGE): By not providing \"FindQt5Core.cmake\" in CMAKE_MODULE_PATH this project has asked CMake to find a package configuration file provided by \"Qt5Core\", but CMake did not find one. 1、打开vlc-qt源码目录下的CMakeLists.txt 2、在SET(PROJECT_DESCRIPTION \"VLC-Qt - Qt bindings for libVLC\")下方添加一行 SET(CMAKE_PREFIX_PATH \"/opt/Qt5.6.2/5.6/gcc_64\") 注意一点的是CMAKE_PREFIX_PATH的目录的指向必须是在包含有bin lib include等这些QT的安装目录。 USB摄像头权限不足时 snap connections vlc 查看是否允许访问设备 snap connect vlc:camera :camera 这将在接口和插槽之间建立连接： ffmpeg安装 sudo apt-get install -y autoconf automake build-essential git libass-dev libfreetype6-dev libsdl2-dev libtheora-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev pkg-config texinfo wget zlib1g-dev ","date":"2020-09-05","objectID":"/vlc%E7%BC%96%E8%AF%91/:0:0","tags":["音视频"],"title":"VLC编译","uri":"/vlc%E7%BC%96%E8%AF%91/"},{"categories":["Docker"],"content":"[TOC] 1. docker实例 下面使用ubuntu:18.04作为例子 ","date":"2020-05-05","objectID":"/docker%E5%AE%9E%E4%BE%8B/:0:0","tags":["Docker"],"title":"Docker实例","uri":"/docker%E5%AE%9E%E4%BE%8B/"},{"categories":["Docker"],"content":"1.1. 镜像使用 ","date":"2020-05-05","objectID":"/docker%E5%AE%9E%E4%BE%8B/:1:0","tags":["Docker"],"title":"Docker实例","uri":"/docker%E5%AE%9E%E4%BE%8B/"},{"categories":["Docker"],"content":"1.1.1. 获取镜像 docker pull ubuntu:18.04 等待下载完成后,查看宿主机镜像 docker images 我们可以看刚刚下载下来的镜像 ","date":"2020-05-05","objectID":"/docker%E5%AE%9E%E4%BE%8B/:1:1","tags":["Docker"],"title":"Docker实例","uri":"/docker%E5%AE%9E%E4%BE%8B/"},{"categories":["Docker"],"content":"1.1.2. 运行镜像 docker run -it ubuntu:18.04 bash 此时我们即启动了该镜像 此处需要说明，每一次使用镜像运行，都会生成一个容器,退出的容器并不会立即删除，除非手动 docker rm,如果不需要排障和保留结果可以使用以下命令 docker run -it --rm ubuntu:18.04 bash –rm 参数使docker不会保留该容器，会在容器退出后将其删除 ","date":"2020-05-05","objectID":"/docker%E5%AE%9E%E4%BE%8B/:1:2","tags":["Docker"],"title":"Docker实例","uri":"/docker%E5%AE%9E%E4%BE%8B/"},{"categories":["Docker"],"content":"1.1.3. 操作容器 当使用docker run -it ubuntu:18.04 bash会在本地生成一个容器，容器和镜像的关系相当于对象和类，查看本地容器 docker ps -a 启动一个已经停止的容器 docker start b8ed1b0ee812 //containerID/name 捕获一个正在运行的容器，使其转到前台bash docker attach b8ed1b0ee812 //containerID/name attach捕获后推出容器，此容器会停止，如果想推出后继续在后台运行使用exec命令 docker exec -it b8ed1b0ee812 /bin/bash ","date":"2020-05-05","objectID":"/docker%E5%AE%9E%E4%BE%8B/:1:3","tags":["Docker"],"title":"Docker实例","uri":"/docker%E5%AE%9E%E4%BE%8B/"},{"categories":["Docker"],"content":"1.1.4. 网络端口映射 当在docker中的服务需要监听宿主机的某些网络应用时，我们使用网络端口映射来达成访问。 docker run -itd -p 5000:5000 ubuntu bash -p 是容器内部端口绑定到指定的主机端口。 -P 是容器内部端口随机映射到主机的高端口。 查看结果： docker ps 绑定特殊IP docker run -itd -p 127.0.0.1:5000:5000 ubuntu bash 使用udp docker run -itd -p 127.0.0.1:5000:5000/udp ubuntu bash ","date":"2020-05-05","objectID":"/docker%E5%AE%9E%E4%BE%8B/:1:4","tags":["Docker"],"title":"Docker实例","uri":"/docker%E5%AE%9E%E4%BE%8B/"},{"categories":["Docker"],"content":"1.1.5. 创建镜像 如果从仓库下载的镜像无法满足我们的使用需求，我们有两种方案修改镜像。 使用dockerFile自定义镜像 使用commit修改镜像 1.1.5.1. commit修改镜像 有时需要在镜像中安装一些软件，又不需要重新搭建环境，这是可以从已经创建的容器中更新镜像，并且提交这个镜像。就可以得到一个修改过的镜像 进入镜像中: docker exec -it b8ed1b0ee812 /bin/bash 这个例子我们对容器进行ping工具安装 apt-get update apt-get install inetutils-ping 此时**ping**安装完成，使用exit退出容器，使用该容器对镜像进行更新 docker commit -m=\"has update\" -a=\"linjg\" b8ed1b0ee812 testimage/pingubuntu:v2 各个参数说明: -m 提交的描述信息 -a 作者 b8ed1b0ee812 容器ID testimage/pingubuntu:v2 创建的镜像名 镜像提交成功后我们查看镜像 docker images 镜像提交完成 这时候使用该镜像再次生成容器，容器内便会自带ping命令，同理其他程序也可如此操作 1.1.5.2. dockerFile定制镜像 Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 在一个空白目录中新建一个Dockerfile文件添加内容： FROM testimage/pingubuntu:v2 RUN apt-get update RUN apt install -y build-essential FROM为此dockerfile构建的基础镜像，run指令是用来执行命令行命令。上文例子为安装GCC编译器例子。 此处主要讲制作流程，更多指令请参考docker官方文档:https://docs.docker.com/engine/reference/builder/ 保存Dockerfile文件并执行 docker build -t dockfileimage:v3 . docker会对程序进行构建,等待镜像构建完成 耐心等待构建完成后，即可看到自己定制的docker镜像 生成容器查看是否正常。 docker run -it --rm dockfileimage:v3 bash 查看插入的gcc环境是否正常 gcc -v 构建成功 ","date":"2020-05-05","objectID":"/docker%E5%AE%9E%E4%BE%8B/:1:5","tags":["Docker"],"title":"Docker实例","uri":"/docker%E5%AE%9E%E4%BE%8B/"},{"categories":["Docker"],"content":"docker常用命令 ","date":"2020-04-06","objectID":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["Docker"],"title":"Docker常用命令","uri":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Docker"],"content":"示例 ","date":"2020-04-06","objectID":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["Docker"],"title":"Docker常用命令","uri":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Docker"],"content":"1.helloworld的调用 从仓库将image抓取到本地 docker image pull library/hello-world docker image pull是抓取image文件的命令。ibrary/hello-world是镜像文件在仓库的位置，其中library是image文件所在的组，hello-world是 image 文件的名字。 获得管理员权限（对宿主机的访问） docker run -it --privileged --rm ubuntu:18.04 bash 查看本地镜像文件: docker image ls 运行镜像，会生成一个容器实例，镜像和容器的关系就像是类和对象的关系。 查看当前所有容器 docker container ls 查看当前电脑所有容器，包括终止运行的容器 docker container ls –all 终止运行的容器文件，依然会占据硬盘空间，下面是删除指令 docker container rm [containerID] 除过以上我们使用的Docker命令外，Docker还有一些其它常用的命令 拉取docker镜像 docker pull image_name 设置docker开机自启动 systemctl enable docker 从镜像中构建容器 docker run -it ubuntu:18.04 bash 从镜像中构建容器，退出容器后不保留容器 docker run -it --rm ubuntu:18.04 bash 开机自启动容器 docker update –restart=always xxx 查看宿主机上的镜像，Docker镜像保存在/var/lib/docker目录下: docker images 删除镜像 docker rmi docker.io/tomcat:7.0.77-jre7 或者 docker rmi b39c68b7af30 查看当前有哪些容器正在运行 docker ps 查看所有容器 docker ps -a 启动、停止、重启容器命令： docker start container_name/container_id docker stop container_name/container_id docker restart container_name/container_id 后台启动一个容器后，如果想进入到这个容器，可以使用attach命令： docker attach container_name/container_id 删除容器的命令： docker rm container_name/container_id 查看当前系统Docker信息 docker info 从Docker hub上下载某个镜像: docker pull centos:latest docker pull centos:latest 执行docker pull centos会将Centos这个仓库下面的所有镜像下载到本地repository。 ","date":"2020-04-06","objectID":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:1","tags":["Docker"],"title":"Docker常用命令","uri":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Docker"],"content":"docker安装 ","date":"2020-04-05","objectID":"/docker%E5%AE%89%E8%A3%85/:0:0","tags":["Docker"],"title":"Docker安装","uri":"/docker%E5%AE%89%E8%A3%85/"},{"categories":["Docker"],"content":"安装 ","date":"2020-04-05","objectID":"/docker%E5%AE%89%E8%A3%85/:1:0","tags":["Docker"],"title":"Docker安装","uri":"/docker%E5%AE%89%E8%A3%85/"},{"categories":["Docker"],"content":"1.卸载旧版本 Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。如果已安装，请卸载它们： sudo apt-get remove docker docker-engine docker.io containerd runc ","date":"2020-04-05","objectID":"/docker%E5%AE%89%E8%A3%85/:1:1","tags":["Docker"],"title":"Docker安装","uri":"/docker%E5%AE%89%E8%A3%85/"},{"categories":["Docker"],"content":"2.使用 APT 安装 sudo apt-get update 安装 apt 依赖包，用于通过HTTPS来获取仓库: sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥 添加 Docker 的官方 GPG 密钥： $ curl \\-fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt\\-key add \\- 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。 $ sudo apt-key fingerprint 0EBFCD88 pub rsa4096 2017-02-22 [SCEA] 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 uid [ unknown] Docker Release (CE deb) \u003cdocker@docker.com\u003e sub rsa4096 2017-02-22 [S] ","date":"2020-04-05","objectID":"/docker%E5%AE%89%E8%A3%85/:2:0","tags":["Docker"],"title":"Docker安装","uri":"/docker%E5%AE%89%E8%A3%85/"},{"categories":["Docker"],"content":"安装 Docker Engine-Community 安装最新版本的 Docker Engine-Community 和 containerd sudo apt-get install docker-ce docker-ce-cli containerd.io ","date":"2020-04-05","objectID":"/docker%E5%AE%89%E8%A3%85/:3:0","tags":["Docker"],"title":"Docker安装","uri":"/docker%E5%AE%89%E8%A3%85/"},{"categories":["Docker"],"content":"修改image 仓库的镜像网址 国内访问 Docker 的官方仓库很慢，还经常断线，所以要把仓库网址改成国内的镜像站。 打开/etc/default/docker文件（需要sudo权限) sudo gedit /etc/default/docker 在文件的底部加上一行。 DOCKER_OPTS=\"--registry-mirror=https://registry.docker-cn.com\" 然后，重启 Docker 服务。 $ sudo service docker restart 现在就会自动从镜像仓库下载 image 文件了。 ","date":"2020-04-05","objectID":"/docker%E5%AE%89%E8%A3%85/:4:0","tags":["Docker"],"title":"Docker安装","uri":"/docker%E5%AE%89%E8%A3%85/"},{"categories":["Docker"],"content":"测试 Docker 是否安装成功 测试 Docker 是否安装成功，输入以下指令，打印出以下信息则安装成功: sudo docker run hello-world ","date":"2020-04-05","objectID":"/docker%E5%AE%89%E8%A3%85/:5:0","tags":["Docker"],"title":"Docker安装","uri":"/docker%E5%AE%89%E8%A3%85/"},{"categories":["Linux"],"content":"ubuntu开机自启动GUI界面 ","date":"2020-03-06","objectID":"/ubuntu%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8gui%E7%95%8C%E9%9D%A2/:1:0","tags":["Linux"],"title":"Ubuntu开机自启动GUI界面","uri":"/ubuntu%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8gui%E7%95%8C%E9%9D%A2/"},{"categories":["Linux"],"content":"1.不需要GUI的后台程序只需输入 sudo gedit /etc/rc.local 在exit 0 前添加一行 cd /home/lin/; ./run_guard.sh \u0026 即可正常开启启动程序 2.开机启动GUI界面程序 由于GUI界面需要在xserver服务启动之后才能启动，放在rc.local中会调用失败 XServer启动的时候会调用 /etc/X11/Xsession.d/55gnome-session_gnomerc 该脚本的内容就是检测 $HOME/.gnomerc是否存在，如果存在就调用 所以: gedit ~/.gnomerc 放入下列脚本即可 #!/bin/bash cd /home/lin/ ./run_guard.sh \u0026 ","date":"2020-03-06","objectID":"/ubuntu%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8gui%E7%95%8C%E9%9D%A2/:1:1","tags":["Linux"],"title":"Ubuntu开机自启动GUI界面","uri":"/ubuntu%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8gui%E7%95%8C%E9%9D%A2/"},{"categories":["Linux"],"content":"开机不启动桌面登录程序 实现这个功能，要完成两步： 1、系统设置-\u003e用户账户-\u003e点击我的账户-\u003e点击右上角的解锁-\u003e打开自动登录-\u003e点击右上角的锁定-\u003e退出系统设置 2、在/etc/profile文件的开头添加执行程序的命令。如： cd /home/xx/xx(这里是可执行文件的绝对路径) ./hello 或者直接写： /home/xx/xx/hello ","date":"2020-03-06","objectID":"/ubuntu%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8gui%E7%95%8C%E9%9D%A2/:2:0","tags":["Linux"],"title":"Ubuntu开机自启动GUI界面","uri":"/ubuntu%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8gui%E7%95%8C%E9%9D%A2/"},{"categories":["Linux"],"content":"程序不休眠 在桌面右上角设置的不挂起，要在桌面加载之后才会生效，当我们无桌面或将桌面禁用就可以用到下列方法 在/etc/profile中添加 export DISPLAY=:0 xset -dpms xset s 0 ","date":"2020-03-06","objectID":"/ubuntu%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8gui%E7%95%8C%E9%9D%A2/:3:0","tags":["Linux"],"title":"Ubuntu开机自启动GUI界面","uri":"/ubuntu%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8gui%E7%95%8C%E9%9D%A2/"},{"categories":["linux"],"content":"linux内存分布 ","date":"2020-02-05","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:0:0","tags":["linux"],"title":"linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["linux"],"content":"X86 平台 Linux 进程内存布局 ","date":"2020-02-05","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:1:0","tags":["linux"],"title":"linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["linux"],"content":"什么是虚拟空间 虚拟空间可以认为是操作系统给每个进程准备的沙盒，就像电影《黑客帝国》中 Matrix 给每个人准备的充满营养液的容器一样。 实际上，每个进程只存活在自己的虚拟世界里，却感觉自己独占了所有的系统资源（内存）。 当一个进程要使用某块内存时，它会将自己世界里的一个内存地址告诉操作系统，剩下的事情就由操作系统接管了。 操作系统中的内存管理策略将决定映射哪块真实的物理内存，供应用使用。操作系统会竭尽全力满足所有进程合法的内存访问请求。 一旦发现应用试图访问非法内存，它将会把进程杀死，防止它做“坏事”影响到系统或其他进程。 这样做，一方面为了安全，防止进程操作其他进程或者系统内核的数据；另一方面为了保证系统可同时运行多个进程，且单个进程使用的内存空间可以超过实际的物理内存容量。 该做法的另一结果则是降低了每个进程内存管理的复杂度，进程只需关心如何使用自己线性排列的虚拟地址，而不需关心物理内存的实际容量，以及如何使用真实的物理内存。 ","date":"2020-02-05","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:1:1","tags":["linux"],"title":"linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["linux"],"content":"进程内存布局 在多任务操作系统中的每一个进程都运行在一个属于它自己的内存沙盘中。这个沙盘就是虚拟地址空间（virtual address space），在32位模式下它总是一个4GB的内存地址块。这些虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每一个进程拥有一套属于它自己的页表，但是还有一个隐情。只要虚拟地址被使能，那么它就会作用于这台机器上运行的所有软件，包括内核本身。因此一部分虚拟地址必须保留给内核使用： 这并不意味着内核使用了那么多的物理内存，仅表示它可支配这么大的地址空间，可根据内核需要，将其映射到物理内存。内核空间在页表中拥有较高的特权级（ring 2 或以下），因此只要用户态的程序试图访问这些页，就会导致一个页错误（page fault）。在 Linux 中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址的，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化： 蓝色区域表示映射到物理内存的虚拟地址，而白色区域表示未映射的部分。在上面的例子中，Firefox 使用了相当多的虚拟地址空间，因为它是传说中的吃内存大户。 ","date":"2020-02-05","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:1:2","tags":["linux"],"title":"linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["linux"],"content":"虚拟空间地址排布 在 32 位系统下，进程的虚拟地址空间有 4G，其中的 1G 分配给了内核空间，用户应用可以使用剩余的 3G。 在 64 位的 Linux 系统上，进程的虚拟地址空间可以达到 256TB，内核和应用分别占用 128TB。目前看来，这样的地址空间范围足够用了。 图#1中，《深入程序布局内部》中讨论过的内容，是按照 ELF 文件中的程序头信息，加载文件内容所得到的。除此之外，加载器还会为每个应用分配栈区（Stack）、堆区（Heap）和动态链接库加载区。栈和堆分别向相对的方向增长，系统会有相应的保护措施，阻止越界行为发生。 栈 - 专门用来存储局部变量，所有的局部变量都是声明在栈区域当中。 堆 - 允许程序员手动的从堆申请空间来使用。程序员可以自己申请指定字节数的空间。 BSS段 - 用来存储未初始化的全局变量和静态变量，声明一个全局变量，如果我们没有初始化，在程序运行最开始的时候，这个变量没有初始化时是存储在BSS段，初始化之后，全局变量和静态变量就会被放到常量区。 数据段/常量区 - 用来存储已经初始化的全局变量、静态变量，还有常量数据 代码段 - 用来存储程序的代码/指令。 在采用段式内存管理的架构中（比如intel的80x86系统），bss段通常是指用来存放程序中未初始化的全局变量的一块内存区域， 一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。 比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中。 text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载； 而bss段不在可执行文件中，由系统初始化。 ","date":"2020-02-05","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:2:0","tags":["linux"],"title":"linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["linux"],"content":"查看进程内存排布 在 Linux 系统中，使用如下命令可查看一个运行中的进程的内存排布。 cat /proc/PID/maps 从以上输出的内容中，可以直观看到进程的段、堆区，动态链接库加载区，栈区的逻辑地址排布，以及每块内存区分配到的权限等。 除此之外，还有两块 vdso 和 vsyscall 内存区。它们是一部分内核数据在用户空间的映射，为了提高应用的性能而创建。 ","date":"2020-02-05","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:2:1","tags":["linux"],"title":"linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["linux"],"content":"进程的启动 从用户角度来看，启动一个进程有许多种方式，可以配置开机自启动，可以在 Shell 中手动运行，也可以从脚本或其他进程中启动。 而从开发人员角度看，无非就是两个系统调用，即 fork() 和 execve()。下面就来探究下这两个系统调用的行为细节。 ","date":"2020-02-05","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:3:0","tags":["linux"],"title":"linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["linux"],"content":"fork() 系统调用 fork() 系统调用将创建一个与父进程几乎一样的新进程，之后继续执行下面的指令。程序可以根据 fork() 的返回值，确定当前处于父进程中，还是子进程中——在父进程中，返回值为新创建子进程的进程 ID，在子进程中，返回值是 0。一些使用多进程模型的服务器程序（比如 sshd），就是通过 fork() 系统调用来实现的，每当新用户接入时，系统就会专门创建一个新进程，来服务该用户。 fork() 系统调用所创建的新进程，与其父进程的内存布局和数据几乎一模一样。在内核中，它们的代码段所在的只读存储区会共享相同的物理内存页。可读可写的数据段、堆及栈等内存，内核会使用写时复制技术，为每个进程独立创建一份。 在 fork() 系统调用刚刚执行完的那一刻，子进程即可拥有一份与父进程完全一样的数据拷贝。对于已打开的文件，内核会增加每个文件描述符的引用计数，每个进程都可以用相同的文件句柄访问同一个文件。 深入理解了这些底层行为细节，就可以顺理成章地理解 fork() 的一些行为表现和正确使用规范，无需死记硬背，也可获得一些别人踩过坑后才能获得的经验。 比如，使用多进程模型的网络服务程序中，为什么要在子进程中关闭监听套接字，同时要在父进程中关闭新连接的套接字呢？ 原因在于 fork() 执行之后，所有已经打开的套接字都被增加了引用计数，在其中任一个进程中都无法彻底关闭套接字，只能减少该文件的引用计数。因此，在 fork() 之后，每个进程立即关闭不再需要的文件是个好的策略，否则很容易导致大量没有正确关闭的文件一直占用系统资源的现象。 再比如，下面这段代码是否存在问题？为什么在输出文件中会出现两行重复的文本？ int main(){ FILE * fp = fopen(\"output.txt\", \"w\"); fputs(\"Message in parent\\n\", fp); switch(fork()) { case -1: perror(\"fork failed\"); return -1; case 0: fputs(\"Message in Child\\n\", fp); break; default: break; } fclose(fp); return 0; } 输入文本： [root@TealCode process]# cat output.txt Message in parent Message in parent Message in Child 原因是 fputs 库函数带有缓冲，fork() 创建的子进程完全拷贝父进程用户空间内存时，fputs 库函数的缓冲区也被包含进来了。所以，fork() 执行之后，子进程同样获得了一份 fputs 缓冲区中的数据，导致“Message in parent”这条消息在子进程中又被输出了一次。要解决这个问题，只需在 fork() 之前，利用 fflush 打开文件即可，读者可自行验证。 另外，希望读者自己思考下，利用父子进程共享相同的只读数据段的特性，是不是可以实现一套父子进程间的通信机制呢？ execve() 系统调用 execve() 系统调用的作用是运行另外一个指定的程序。它会把新程序加载到当前进程的内存空间内，当前的进程会被丢弃，它的堆、栈和所有的段数据都会被新进程相应的部分代替，然后会从新程序的初始化代码和 main 函数开始运行。同时，进程的 ID 将保持不变。 execve() 系统调用通常与 fork() 系统调用配合使用。从一个进程中启动另一个程序时，通常是先 fork() 一个子进程，然后在子进程中使用 execve() 变身为运行指定程序的进程。例如，当用户在 Shell 下输入一条命令启动指定程序时，Shell 就是先 fork() 了自身进程，然后在子进程中使用 execve() 来运行指定的程序。 execve() 系统调用的函数原型为： int execve(const char *filename, char *const argv[], char *const envp[]); filename 用于指定要运行的程序的文件名，argv 和 envp 分别指定程序的运行参数和环境变量。除此之外，该系列函数还有很多变体，它们执行大体相同的功能，区别在于需要的参数不同，包括 execl、execlp、execle、execv、execvp、execvpe 等。它们的参数意义和使用方法请读者自行查看帮助手册。 需要注意的是，exec 系列函数的返回值只在遇到错误的时候才有意义。如果新程序成功地被执行，那么当前进程的所有数据就都被新进程替换掉了，所以永远也不会有任何返回值。 对于已打开文件的处理，在 exec() 系列函数执行之前，应该确保全部关闭。因为 exec() 调用之后，当前进程就完全变身成另外一个进程了，老进程的所有数据都不存在了。如果 exec() 调用失败，当前打开的文件状态应该被保留下来。让应用层处理这种情况会非常棘手，而且有些文件可能是在某个库函数内部打开的，应用对此并不知情，更谈不上正确地维护它们的状态了。 所以，对于执行 exec() 函数的应用，应该总是使用内核为文件提供的执行时关闭标志（FD_CLOEXEC）。设置了该标志之后，如果 exec() 执行成功，文件就会被自动关闭；如果 exec() 执行失败，那么文件会继续保持打开状态。使用系统调用 fcntl() 可以设置该标志。 fexecve() 函数 glibc 从 2.3.2 版本开始提供 fexecv() 函数，它与 execve() 的区别在于，第一个参数使用的是打开的文件描述符，而非文件路径名。 增加这个函数是为了满足这样的应用需求：有些应用在执行某个程序文件之前，需要先打开文件验证文件内容的校验和，确保文件内容没有被恶意修改过。 在这种情景下，使用 fexecve 是更加安全的方案。组合使用 open() 和 execve() 虽然可以实现同样的功能，但是在打开文件和执行文件之间，存在被执行的程序文件被掉包的可能性。 ","date":"2020-02-05","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:3:1","tags":["linux"],"title":"linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["linux"],"content":"监控子进程状态 在 Linux 应用中，父进程需要监控其创建的所有子进程的退出状态，可以通过如下几个系统调用来实现。 pid_t wait(int * statua) 一直阻塞地等待任意一个子进程退出，返回值为退出的子进程的 ID，status 中包含子进程设置的退出标志。 pid_t waitpid(pid_t pid, int * status, int options) 可以用 pid 参数指定要等待的进程或进程组的 ID，options 可以控制是否阻塞，以及是否监控因信号而停止的子进程等。 int waittid(idtype_t idtype, id_t id, siginfo_t *infop, int options) 提供比 waitpid 更加精细的控制选项来监控指定子进程的运行状态。 wait3() 和 wait4() 系统调用 可以在子进程退出时，获取到子进程的资源使用数据。 更详细的信息请参考帮助手册。 本文要重点讨论的是：即使父进程在业务逻辑上不关心子进程的终止状态，也需要使用 wait 类系统调用的底层原因。 这其中的要点在于：在 Linux 的内核实现中，允许父进程在子进程创建之后的任意时刻用 wait() 系列系统调用来确定子进程的状态。 也就是说，如果子进程在父进程调用 wait() 之前就终止了，内核需要保留该子进程的终止状态和资源使用等数据，直到父进程执行 wait() 把这些数据取走。 在子进程终止到父进程获取退出状态之间的这段时间，这个进程会变成所谓的僵尸状态，在该状态下，任何信号都无法结束它。如果系统中存在大量此类僵尸进程，势必会占用大量内核资源，甚至会导致新进程创建失败。 如果父进程也终止，那么 init 进程会接管这些僵尸进程并自动调用 wait ，从而把它们从系统中移除。但是对于长期运行的服务器程序，这一定不是开发者希望看到的结果。所以，父进程一定要仔细维护好它创建的所有子进程的状态，防止僵尸进程的产生。 ","date":"2020-02-05","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:3:2","tags":["linux"],"title":"linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["linux"],"content":"进程的终止 正常终止一个进程可以用 _exit 系统调用来实现，原型为： void _exit(int status); 其中的 status 会返回 wait() 类的系统调用。进程退出时会清理掉该进程占用的所有系统资源，包括关闭打开的文件描述符、释放持有的文件锁和内存锁、取消内存映射等，还会给一些子进程发送信号（后面课程再详细展开）。该系统调用一定会成功，永远不会返回。 在退出之前，还希望做一些个性化的清理操作，可以使用库函数 exit() 。函数原型为： void exit(int status); 这个库函数先调用退出处理程序，然后再利用 status 参数调用 _exit() 系统调用。这里的退出处理程序可以通过 atexit() 或 on_exit() 函数注册。其中 atexit() 只能注册返回值和参数都为空的回调函数，而 on_exit() 可以注册带参数的回调函数。退出处理函数的执行顺序与注册顺序相反。它们的函数原型如下所示： int atexit(void (*func)(void));int on_exit(void (*func)(int, void *), void *arg); 通常情况下，个性化的退出处理函数只会在主进程中执行一次，所以 exit() 函数一般在主进程中使用，而在子进程中只使用 _exit() 系统调用结束当前进程。 ","date":"2020-02-05","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:3:3","tags":["linux"],"title":"linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["linux"],"content":"总结 本文深入探究了 Linux 进程在用户空间的一些内部细节，包括逻辑内存排布、进程创建和变身的内部细节、进程状态监控的目的和接口，以及终止进程的正确姿势等。对这些底层实现细节的充分理解，能帮助读者更好地理解各个系统调用的行为表现，并根据具体的应用需求选择正确、合适的实现方案。 ","date":"2020-02-05","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:3:4","tags":["linux"],"title":"linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["Qt"],"content":"PYQT环境搭建与QT异同分析 ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:0:0","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Qt"],"content":"简介 Qt是C++的跨平台框架，Pyqt是一个跨平台的工具包。我们可以直接使用Qt designer绘制出QT的UI界面，使用Pyqt将ui文件转换成Python语法。此外，由于Pyqt使用python语法，本质上是一个解释器，即不需要交叉编译。 ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:1:0","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Qt"],"content":"PYQT环境搭建 pyqt使用环境需要以下几个软件支持 Python主程序 Pycharm Qt5\u003c主要使用QT5中的designer\u003e PyQt库 ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:2:0","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Qt"],"content":"Python主程序下载安装 python官网下载地址 https://www.python.org/downloads/ windows下选择executable安装包进行安装 下载完对应版本后，双击可执行文件对Python进行安装，注意勾选 Add Python 3.7 to PATH （否则需要自己添加系统变量） 默认全部 勾选，点击Next 注意：Python所在的路径建议不要有中文路径。 ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:2:1","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Qt"],"content":"PyCharm安装 下面链接为Pycharm安装包以及破解包，具体安装及破解可以点击链接下载。 链接: https://pan.baidu.com/s/1rPwaMzfUKbisYaAAwwzihg 提取码: mqut ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:3:0","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Qt"],"content":"QT5下载 下面链接提供QT全部版本。建议选择QT5以上，目前本人使用版本为Qt5.9.2 链接: https://download.qt.io/archive/qt/ 下载后安装即可，编译器及组件可根据需要选择下载。 ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:4:0","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Qt"],"content":"PyQt下载 在安装好Python之后，打开命令行，输入以下命令（如果无效，请将Python安装路径加到环境变量中） pip install PyQt5 如果需要指定版本请输入 installpip install PyQt5==5.10.1 5.10.1为对应的版本号，等待Pyqt下载完成后，我们打开PYcharm进行环境配置。 ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:5:0","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Qt"],"content":"PyQT+PyCharm+Qt designer搭建 打开 Pycharm，Files-\u003eSettings-\u003eExternal Tools，添加两个 tools，Qt Designer、PyUIC： 点击+号添加tools Programs:的地方找到你自己的 designer.exe 所在的位置 Working directory:的地方填上`$ProjectFileDir$` 同样的我们添加Pyqt工具 Programs:的地方找到你自己的 python.exe 所在的位置 Arguments:的地方填上-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py Working directory:的地方填上$FileDir$ 至此，Pyqt与Python的环境就搭建完成了 示例 搭建完程序，我们就开始写出我们的第一个Pyqt程序。 点击file—\u003eNew project添加新的项目 点击tools -- External Tools -- Qt Designer 来打开设计师界面 随便先选择一个Widget窗体 点击保存，存放到项目路径下，接着右击该文件，点击PyUIC进行翻译 可以看到生成一个同名的.py程序。 我们新建一个mian.py主程序来调用此界面程序。 在main.py中添加以下代码 # -*- coding: utf-8 -*- import sys import untitled from PyQt5 import QtWidgets,QtCore if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) widget = QtWidgets.QWidget() ui = untitled.Ui_Form() ui.setupUi(widget) widget.show() sys.exit(app.exec_()) 最后右击main.py 点击Run即可看到界面显示出来。 界面如下。我们的第一个Pyqt程序就好了。. 与QT的语法差异 ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:6:0","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Qt"],"content":"QWidget 下面使用Pyqt和Qt实现相同功能的程序，分析两者之间的差距。 Pyqt实现: # -*- coding: utf-8 -*- import sys #这里我们提供必要的引用。基本控件位于pyqt5.qtwidgets模块中。 from PyQt5.QtWidgets import QApplication, QWidget if __name__ == '__main__': #每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数。 app = QApplication(sys.argv) #QWidget部件是pyqt5所有用户界面对象的基类。他为QWidget提供默认构造函数。默认构造函数没有父类。 w = QWidget() #resize()方法调整窗口的大小。这离是250px宽150px高 w.resize(250, 150) #move()方法移动窗口在屏幕上的位置到x = 300，y = 300坐标。 w.move(300, 300) #设置窗口的标题 w.setWindowTitle('Simple') #显示在屏幕上 w.show() #系统exit()方法确保应用程序干净的退出 #的exec_()方法有下划线。因为执行是一个Python关键词。因此，exec_()代替 sys.exit(app.exec_()) QT实现: #include \u003cQApplication\u003e int main(int argc, char *argv[]) { QApplication a(argc, argv); QWidget w; w.resize(250,150); w.move(300,300); w.setWindowTitle(\"Simple\"); w.show(); return a.exec(); } 可以看到，Pyqt和Qt除了C++和Python语法之间的区别之外。库之间的方法命名，调用方式极为相似。 ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:7:0","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Qt"],"content":"信号槽 Qt引以为傲的信号和槽，也完全保留在Pyqt组件上。不过写法略有不同。 下面的例子为按钮点击时触发槽函数的连接语句 Pyqt按钮信号槽示例: self.pushButton.clicked.connect(self.CameraStop)#CameraStop为槽函数 def CameraStop(self): print('暂停截图') self.timer.stop() Qt按钮信号槽示例: connect(ui-\u003epushButton,SIGNAL(clicked(bool)),ui-\u003elabel,SLOT(CameraStop())); void CameraStop() { std::cout\u003c\u003c暂停截图\u003c\u003cendl; this-\u003etimer-\u003estop(); } 通过以上示例，pyqt信号的格式为Sender.signal.connect(receiver.slot)，通过调用pushButton的clicked中的connect方法来绑定槽函数。Qt则是通过外部静态函数QObject::connect(sender, SIGNAL(what), receiver, SLOT(doWhat()))。来将clicked点击信号和CameraStop接收信号绑定在一起。 ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:8:0","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Qt"],"content":"控件重写 下面重写一个QT的QLabal，实现绘制多矩形框与输出坐标的功能。 Pyqt实现： class MyLabel(QLabel): flag = False isDraw = False isSuccess = False tempRect =QRect() #保存一个矩形坐标数据 rectVector = list() #重写鼠标单击事件 def mousePressEvent(self,event): if self.isDraw: self.flag = True self.tempRect.setX(event.x()) self.tempRect.setY(event.y()) #重写鼠标释放事件 def mouseReleaseEvent(self,event): self.flag = False if self.isDraw: self.flag = False self.isSuccess = True self.rectVector.append(copy.deepcopy(self.tempRect)) print(self.rectVector) self.tempRect.setCoords(0,0,0,0) #重写鼠标移动事件 def mouseMoveEvent(self,event): if self.isDraw and self.flag: self.tempRect.setHeight(event.y()-self.tempRect.y()) self.tempRect.setWidth(event.x()-self.tempRect.x()) self.update() #重写绘图事件 def paintEvent(self, event): super().paintEvent(event)#调用父类绘图 painter = QPainter(self) painter.setPen(QPen(Qt.red,2,Qt.SolidLine)) for Rect in self.rectVector: painter.drawRect(Rect) print(Rect.x()) if self.isDraw: painter.drawRect(self.tempRect) print(len(self.rectVector)) def rollback(self): if len(self.rectVector) != 0: self.rectVector.pop() self.update() def RectClean(self): self.rectVector.clear() Qt实现 //头文件 #include\u003cQtWidgets\u003e#include\u003cQObject\u003e#include \u003cQWidget\u003e#include\u003cQVector\u003eclass QmyLabel :public QLabel { Q_OBJECT public: QmyLabel(QWidget *parent = 0); //重写事件 void mousePressEvent(QMouseEvent *ev); void mouseReleaseEvent(QMouseEvent *ev); void mouseMoveEvent(QMouseEvent *ev); void paintEvent(QPaintEvent *ev); void RectsClear(); QVector\u003cQRect\u003e getVector(); bool isDraw;//是否能够绘制 public slots: void rollback();//撤销 private: bool flag;//判断是否在绘制 bool isSuccess; QRect tempRect; QVector\u003cQRect\u003e rectVector;//保存全部点的坐标 }; //.cpp文件 #include \"qmylabel.h\"QmyLabel::QmyLabel(QWidget *parent): QLabel(parent) { this-\u003eflag=false; this-\u003eisDraw = false; this-\u003eisSuccess = false; //tempRect.setRect(0,0,0,0); } void QmyLabel::mousePressEvent(QMouseEvent *ev) { //鼠标点击事件,获取左上角位置 if(this-\u003eisDraw == true) { this-\u003eflag=true; //this-\u003etempRect.setTopLeft(QPoint(ev-\u003ex(),ev-\u003ey())); this-\u003etempRect.setX(ev-\u003ex()); this-\u003etempRect.setY(ev-\u003ey()); qDebug()\u003c\u003c\"mousePressEvent...\"; } } void QmyLabel::mouseReleaseEvent(QMouseEvent *ev) { if(this-\u003eisDraw == true) { //鼠标释放事件,将tempRect数据存放进数组中. this-\u003eflag = false; this-\u003eisSuccess = true; this-\u003erectVector.append(tempRect); tempRect.setCoords(0,0,0,0); qDebug()\u003c\u003c\"mouseReleaseEvent...\"; } } void QmyLabel::mouseMoveEvent(QMouseEvent *ev) { if(this-\u003eflag \u0026\u0026this-\u003eisDraw == true) { this-\u003etempRect.setHeight(ev-\u003ey()-this-\u003etempRect.y()); this-\u003etempRect.setWidth(ev-\u003ex()-this-\u003etempRect.x()); this-\u003eupdate(); } } void QmyLabel::paintEvent(QPaintEvent *ev) { QLabel::paintEvent(ev); //绘制背景的图片 QPainter paint; paint.begin(this); paint.setPen(QPen(Qt::red, 2, Qt::SolidLine, Qt::RoundCap)); for(int i=0;i\u003cthis-\u003erectVector.size();i++) { paint.drawRect(rectVector.value(i)); } if(this-\u003eisDraw == true) { paint.drawRect(tempRect); } paint.end(); } void QmyLabel::RectsClear() { this-\u003erectVector.clear(); } QVector\u003cQRect\u003e QmyLabel::getVector() { return this-\u003erectVector; } void QmyLabel::rollback() { if(this-\u003erectVector.size()!=0)//有值 { this-\u003erectVector.removeLast(); update(); } } Pyqt和Qt重写控件的方式基本相同，但是需要注意，Python在list中添加一个对象，如rectVector.append(对象)，当我们修改对象的某个属性，再次将其添加进list。这时候之前添加进list的对象属性也会改变，但是在QT中不会发生此类事情。推测，Python中的链表添加数据时使用的不是拷贝，而是引用。所以这里需要使用深拷贝copy.deepcopy() ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:9:0","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Qt"],"content":"注意事项 PyQt不支持使用QVector,QList等Qt容器，可以使用Python中自带的容器list,dict等进行替换。 ","date":"2019-10-19","objectID":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/:10:0","tags":["Qt"],"title":"PYQT环境搭建与QT异同分析","uri":"/pyqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8Eqt%E5%BC%82%E5%90%8C%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"linux内存分布 ","date":"2019-10-15","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:0:0","tags":["Linux"],"title":"Linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["Linux"],"content":"X86 平台 Linux 进程内存布局 ","date":"2019-10-15","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:1:0","tags":["Linux"],"title":"Linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["Linux"],"content":"什么是虚拟空间 虚拟空间可以认为是操作系统给每个进程准备的沙盒，就像电影《黑客帝国》中 Matrix 给每个人准备的充满营养液的容器一样。 实际上，每个进程只存活在自己的虚拟世界里，却感觉自己独占了所有的系统资源（内存）。 当一个进程要使用某块内存时，它会将自己世界里的一个内存地址告诉操作系统，剩下的事情就由操作系统接管了。 操作系统中的内存管理策略将决定映射哪块真实的物理内存，供应用使用。操作系统会竭尽全力满足所有进程合法的内存访问请求。 一旦发现应用试图访问非法内存，它将会把进程杀死，防止它做“坏事”影响到系统或其他进程。 这样做，一方面为了安全，防止进程操作其他进程或者系统内核的数据；另一方面为了保证系统可同时运行多个进程，且单个进程使用的内存空间可以超过实际的物理内存容量。 该做法的另一结果则是降低了每个进程内存管理的复杂度，进程只需关心如何使用自己线性排列的虚拟地址，而不需关心物理内存的实际容量，以及如何使用真实的物理内存。 ","date":"2019-10-15","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:1:1","tags":["Linux"],"title":"Linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["Linux"],"content":"进程内存布局 在多任务操作系统中的每一个进程都运行在一个属于它自己的内存沙盘中。这个沙盘就是虚拟地址空间（virtual address space），在32位模式下它总是一个4GB的内存地址块。这些虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每一个进程拥有一套属于它自己的页表，但是还有一个隐情。只要虚拟地址被使能，那么它就会作用于这台机器上运行的所有软件，包括内核本身。因此一部分虚拟地址必须保留给内核使用： 这并不意味着内核使用了那么多的物理内存，仅表示它可支配这么大的地址空间，可根据内核需要，将其映射到物理内存。内核空间在页表中拥有较高的特权级（ring 2 或以下），因此只要用户态的程序试图访问这些页，就会导致一个页错误（page fault）。在 Linux 中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址的，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化： 蓝色区域表示映射到物理内存的虚拟地址，而白色区域表示未映射的部分。在上面的例子中，Firefox 使用了相当多的虚拟地址空间，因为它是传说中的吃内存大户。 ","date":"2019-10-15","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:1:2","tags":["Linux"],"title":"Linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["Linux"],"content":"虚拟空间地址排布 在 32 位系统下，进程的虚拟地址空间有 4G，其中的 1G 分配给了内核空间，用户应用可以使用剩余的 3G。 在 64 位的 Linux 系统上，进程的虚拟地址空间可以达到 256TB，内核和应用分别占用 128TB。目前看来，这样的地址空间范围足够用了。 图#1中，《深入程序布局内部》中讨论过的内容，是按照 ELF 文件中的程序头信息，加载文件内容所得到的。除此之外，加载器还会为每个应用分配栈区（Stack）、堆区（Heap）和动态链接库加载区。栈和堆分别向相对的方向增长，系统会有相应的保护措施，阻止越界行为发生。 栈 - 专门用来存储局部变量，所有的局部变量都是声明在栈区域当中。 堆 - 允许程序员手动的从堆申请空间来使用。程序员可以自己申请指定字节数的空间。 BSS段 - 用来存储未初始化的全局变量和静态变量，声明一个全局变量，如果我们没有初始化，在程序运行最开始的时候，这个变量没有初始化时是存储在BSS段，初始化之后，全局变量和静态变量就会被放到常量区。 数据段/常量区 - 用来存储已经初始化的全局变量、静态变量，还有常量数据 代码段 - 用来存储程序的代码/指令。 ","date":"2019-10-15","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:2:0","tags":["Linux"],"title":"Linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["Linux"],"content":"查看进程内存排布 在 Linux 系统中，使用如下命令可查看一个运行中的进程的内存排布。 cat /proc/PID/maps 从以上输出的内容中，可以直观看到进程的段、堆区，动态链接库加载区，栈区的逻辑地址排布，以及每块内存区分配到的权限等。 除此之外，还有两块 vdso 和 vsyscall 内存区。它们是一部分内核数据在用户空间的映射，为了提高应用的性能而创建。 ","date":"2019-10-15","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:2:1","tags":["Linux"],"title":"Linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["Linux"],"content":"进程的启动 从用户角度来看，启动一个进程有许多种方式，可以配置开机自启动，可以在 Shell 中手动运行，也可以从脚本或其他进程中启动。 而从开发人员角度看，无非就是两个系统调用，即 fork() 和 execve()。下面就来探究下这两个系统调用的行为细节。 ","date":"2019-10-15","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:3:0","tags":["Linux"],"title":"Linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["Linux"],"content":"fork() 系统调用 fork() 系统调用将创建一个与父进程几乎一样的新进程，之后继续执行下面的指令。程序可以根据 fork() 的返回值，确定当前处于父进程中，还是子进程中——在父进程中，返回值为新创建子进程的进程 ID，在子进程中，返回值是 0。一些使用多进程模型的服务器程序（比如 sshd），就是通过 fork() 系统调用来实现的，每当新用户接入时，系统就会专门创建一个新进程，来服务该用户。 fork() 系统调用所创建的新进程，与其父进程的内存布局和数据几乎一模一样。在内核中，它们的代码段所在的只读存储区会共享相同的物理内存页。可读可写的数据段、堆及栈等内存，内核会使用写时复制技术，为每个进程独立创建一份。 在 fork() 系统调用刚刚执行完的那一刻，子进程即可拥有一份与父进程完全一样的数据拷贝。对于已打开的文件，内核会增加每个文件描述符的引用计数，每个进程都可以用相同的文件句柄访问同一个文件。 深入理解了这些底层行为细节，就可以顺理成章地理解 fork() 的一些行为表现和正确使用规范，无需死记硬背，也可获得一些别人踩过坑后才能获得的经验。 比如，使用多进程模型的网络服务程序中，为什么要在子进程中关闭监听套接字，同时要在父进程中关闭新连接的套接字呢？ 原因在于 fork() 执行之后，所有已经打开的套接字都被增加了引用计数，在其中任一个进程中都无法彻底关闭套接字，只能减少该文件的引用计数。因此，在 fork() 之后，每个进程立即关闭不再需要的文件是个好的策略，否则很容易导致大量没有正确关闭的文件一直占用系统资源的现象。 再比如，下面这段代码是否存在问题？为什么在输出文件中会出现两行重复的文本？ int main(){ FILE * fp = fopen(\"output.txt\", \"w\"); fputs(\"Message in parent\\n\", fp); switch(fork()) { case -1: perror(\"fork failed\"); return -1; case 0: fputs(\"Message in Child\\n\", fp); break; default: break; } fclose(fp); return 0; } 输入文本： [root@TealCode process]# cat output.txt Message in parent Message in parent Message in Child 原因是 fputs 库函数带有缓冲，fork() 创建的子进程完全拷贝父进程用户空间内存时，fputs 库函数的缓冲区也被包含进来了。所以，fork() 执行之后，子进程同样获得了一份 fputs 缓冲区中的数据，导致“Message in parent”这条消息在子进程中又被输出了一次。要解决这个问题，只需在 fork() 之前，利用 fflush 打开文件即可，读者可自行验证。 另外，希望读者自己思考下，利用父子进程共享相同的只读数据段的特性，是不是可以实现一套父子进程间的通信机制呢？ execve() 系统调用 execve() 系统调用的作用是运行另外一个指定的程序。它会把新程序加载到当前进程的内存空间内，当前的进程会被丢弃，它的堆、栈和所有的段数据都会被新进程相应的部分代替，然后会从新程序的初始化代码和 main 函数开始运行。同时，进程的 ID 将保持不变。 execve() 系统调用通常与 fork() 系统调用配合使用。从一个进程中启动另一个程序时，通常是先 fork() 一个子进程，然后在子进程中使用 execve() 变身为运行指定程序的进程。例如，当用户在 Shell 下输入一条命令启动指定程序时，Shell 就是先 fork() 了自身进程，然后在子进程中使用 execve() 来运行指定的程序。 execve() 系统调用的函数原型为： int execve(const char *filename, char *const argv[], char *const envp[]); filename 用于指定要运行的程序的文件名，argv 和 envp 分别指定程序的运行参数和环境变量。除此之外，该系列函数还有很多变体，它们执行大体相同的功能，区别在于需要的参数不同，包括 execl、execlp、execle、execv、execvp、execvpe 等。它们的参数意义和使用方法请读者自行查看帮助手册。 需要注意的是，exec 系列函数的返回值只在遇到错误的时候才有意义。如果新程序成功地被执行，那么当前进程的所有数据就都被新进程替换掉了，所以永远也不会有任何返回值。 对于已打开文件的处理，在 exec() 系列函数执行之前，应该确保全部关闭。因为 exec() 调用之后，当前进程就完全变身成另外一个进程了，老进程的所有数据都不存在了。如果 exec() 调用失败，当前打开的文件状态应该被保留下来。让应用层处理这种情况会非常棘手，而且有些文件可能是在某个库函数内部打开的，应用对此并不知情，更谈不上正确地维护它们的状态了。 所以，对于执行 exec() 函数的应用，应该总是使用内核为文件提供的执行时关闭标志（FD_CLOEXEC）。设置了该标志之后，如果 exec() 执行成功，文件就会被自动关闭；如果 exec() 执行失败，那么文件会继续保持打开状态。使用系统调用 fcntl() 可以设置该标志。 fexecve() 函数 glibc 从 2.3.2 版本开始提供 fexecv() 函数，它与 execve() 的区别在于，第一个参数使用的是打开的文件描述符，而非文件路径名。 增加这个函数是为了满足这样的应用需求：有些应用在执行某个程序文件之前，需要先打开文件验证文件内容的校验和，确保文件内容没有被恶意修改过。 在这种情景下，使用 fexecve 是更加安全的方案。组合使用 open() 和 execve() 虽然可以实现同样的功能，但是在打开文件和执行文件之间，存在被执行的程序文件被掉包的可能性。 ","date":"2019-10-15","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:3:1","tags":["Linux"],"title":"Linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["Linux"],"content":"监控子进程状态 在 Linux 应用中，父进程需要监控其创建的所有子进程的退出状态，可以通过如下几个系统调用来实现。 pid_t wait(int * statua) 一直阻塞地等待任意一个子进程退出，返回值为退出的子进程的 ID，status 中包含子进程设置的退出标志。 pid_t waitpid(pid_t pid, int * status, int options) 可以用 pid 参数指定要等待的进程或进程组的 ID，options 可以控制是否阻塞，以及是否监控因信号而停止的子进程等。 int waittid(idtype_t idtype, id_t id, siginfo_t *infop, int options) 提供比 waitpid 更加精细的控制选项来监控指定子进程的运行状态。 wait3() 和 wait4() 系统调用 可以在子进程退出时，获取到子进程的资源使用数据。 更详细的信息请参考帮助手册。 本文要重点讨论的是：即使父进程在业务逻辑上不关心子进程的终止状态，也需要使用 wait 类系统调用的底层原因。 这其中的要点在于：在 Linux 的内核实现中，允许父进程在子进程创建之后的任意时刻用 wait() 系列系统调用来确定子进程的状态。 也就是说，如果子进程在父进程调用 wait() 之前就终止了，内核需要保留该子进程的终止状态和资源使用等数据，直到父进程执行 wait() 把这些数据取走。 在子进程终止到父进程获取退出状态之间的这段时间，这个进程会变成所谓的僵尸状态，在该状态下，任何信号都无法结束它。如果系统中存在大量此类僵尸进程，势必会占用大量内核资源，甚至会导致新进程创建失败。 如果父进程也终止，那么 init 进程会接管这些僵尸进程并自动调用 wait ，从而把它们从系统中移除。但是对于长期运行的服务器程序，这一定不是开发者希望看到的结果。所以，父进程一定要仔细维护好它创建的所有子进程的状态，防止僵尸进程的产生。 ","date":"2019-10-15","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:3:2","tags":["Linux"],"title":"Linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["Linux"],"content":"进程的终止 正常终止一个进程可以用 _exit 系统调用来实现，原型为： void _exit(int status); 其中的 status 会返回 wait() 类的系统调用。进程退出时会清理掉该进程占用的所有系统资源，包括关闭打开的文件描述符、释放持有的文件锁和内存锁、取消内存映射等，还会给一些子进程发送信号（后面课程再详细展开）。该系统调用一定会成功，永远不会返回。 在退出之前，还希望做一些个性化的清理操作，可以使用库函数 exit() 。函数原型为： void exit(int status); 这个库函数先调用退出处理程序，然后再利用 status 参数调用 _exit() 系统调用。这里的退出处理程序可以通过 atexit() 或 on_exit() 函数注册。其中 atexit() 只能注册返回值和参数都为空的回调函数，而 on_exit() 可以注册带参数的回调函数。退出处理函数的执行顺序与注册顺序相反。它们的函数原型如下所示： int atexit(void (*func)(void));int on_exit(void (*func)(int, void *), void *arg); 通常情况下，个性化的退出处理函数只会在主进程中执行一次，所以 exit() 函数一般在主进程中使用，而在子进程中只使用 _exit() 系统调用结束当前进程。 ","date":"2019-10-15","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:3:3","tags":["Linux"],"title":"Linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":["Linux"],"content":"总结 本文深入探究了 Linux 进程在用户空间的一些内部细节，包括逻辑内存排布、进程创建和变身的内部细节、进程状态监控的目的和接口，以及终止进程的正确姿势等。对这些底层实现细节的充分理解，能帮助读者更好地理解各个系统调用的行为表现，并根据具体的应用需求选择正确、合适的实现方案。 ","date":"2019-10-15","objectID":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/:3:4","tags":["Linux"],"title":"Linux内存分布","uri":"/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"categories":null,"content":"关于 LoveIt","date":"2019-08-02","objectID":"/about/","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"  LoveIt 是一个由  Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持 Plausible Analytics  支持 Yandex Metrica  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 ","date":"2019-08-02","objectID":"/about/:1:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"外观和布局  桌面端/移动端 响应式布局  浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 73 种社交链接  支持多达 24 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook comments 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 utterances 评论系统  支持 giscus 评论系统 ","date":"2019-08-02","objectID":"/about/:1:2","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightGallery 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $\\KaTeX$ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 cookieconsent 的 Cookie 许可横幅  支持人物标签的 shortcode … ","date":"2019-08-02","objectID":"/about/:1:3","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特别感谢 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css autocomplete Lunr.js algoliasearch lazysizes object-fit-images Twemoji emoji-data lightGallery clipboard.js Sharer.js TypeIt $\\KaTeX$ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":["Qt"],"content":"Qt实用函数(长期更新) ","date":"2019-01-05","objectID":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/:0:0","tags":["Qt"],"title":"Qt实用函数","uri":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Qt"],"content":"设置窗体固定大小不可拖动 this-\u003esetFixedSize(this-\u003ewidth(),this-\u003eheight()); ","date":"2019-01-05","objectID":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/:1:0","tags":["Qt"],"title":"Qt实用函数","uri":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Qt"],"content":"窗体显示状态自定义 setWindowFlags(Qt::CustomizeWindowHint); setWindowFlags(Qt::WindowCloseButtonHint); //只要关闭按钮 setWindowFlags(Qt::WindowFlags type) Qt::FrameWindowHint:没有边框的窗口 Qt::WindowStaysOnTopHint: //总在最上面的窗口 Qt::CustomizeWindowHint: //自定义窗口标题栏,以下标志必须与这个标志一起使用才有效,否则窗口将有默认的标题栏 Qt::WindowTitleHint //显示窗口标题栏 Qt::WindowSystemMenuHint //显示系统菜单 Qt::WindowMinimizeButtonHint //显示最小化按钮 Qt::WindowMaximizeButtonHint //显示最大化按钮 Qt::WindowMinMaxButtonsHint //显示最小化按钮和最大化按钮 Qt::WindowCloseButtonHint //显示关闭按钮 ","date":"2019-01-05","objectID":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/:2:0","tags":["Qt"],"title":"Qt实用函数","uri":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Qt"],"content":"乱码解决方案 QApplication a(argc, argv); //获取系统编码，否则移植会出现乱码 QTextCodec *codec = QTextCodec::codecForName(\"UTF-8\"); //设置和对本地文件系统读写时候的默认编码格式 QTextCodec::setCodecForLocale(codec); //设置传给tr函数时的默认字符串编码 QTextCodec::setCodecForTr(codec); //用在字符常量或者QByteArray构造QString对象时使用的一种编码方式 QTextCodec::setCodecForCStrings(codec); ","date":"2019-01-05","objectID":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/:3:0","tags":["Qt"],"title":"Qt实用函数","uri":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Qt"],"content":"隐藏任务栏显示 setWindowFlags(Qt::Tool | Qt::X11BypassWindowManagerHint) ","date":"2019-01-05","objectID":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/:4:0","tags":["Qt"],"title":"Qt实用函数","uri":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Qt"],"content":"关闭按钮实现的功能 hide(); //进行界面隐藏，但是显示托盘，可通过点击托盘实现界面的重新显示 quit(); //退出系统 ","date":"2019-01-05","objectID":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/:5:0","tags":["Qt"],"title":"Qt实用函数","uri":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Qt"],"content":"获取系统当前时间并设置显示格式 QDateTime current_date_time = QDateTime::currentDateTime(); QString current_date = current_date_time.toString(\"yyyy-MM-dd hh:mm:ss ddd\"); 例：2013-05-24 13:09:10 周五 获取当前时间时、分、秒 范围：小时(0--23)、分钟(0--59)、秒(0--59)、毫秒(0--999) QTime current_time = QTime::currentTime(); int hour = current_time.hour(); int minute = current_time.minute(); int second = current_time.second(); int msec = current_time.msec(); ","date":"2019-01-05","objectID":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/:6:0","tags":["Qt"],"title":"Qt实用函数","uri":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Qt"],"content":"比较日期大小 //获取当前时间及文件缓存时间 QDateTime currentDateTime = QDateTime::currentDateTime(); QDateTime dateTime = QDateTime::fromString(strDate, sDateTimeFormat); //获取文件缓存一个月之后的时间 QDateTime afterOneMonthDateTime = dateTime.addMonths(1); //如果缓存时间超过一个月，则删除 qint64 nSecs = afterOneMonthDateTime.secsTo(currentDateTime); if (nSecs \u003e 0) { QFile::remove(strFilePath); } QDir::toNativeSeparators 可以智能翻译目录，正常目录位于windows下是\"\\\\\"，位于linux下是\"/\",该静态函数可以返回正确的路径名称 ","date":"2019-01-05","objectID":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/:7:0","tags":["Qt"],"title":"Qt实用函数","uri":"/qt%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/"}]