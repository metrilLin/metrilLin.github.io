<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 保持热爱</title>
    <link>https://metrillin.github.io/posts/</link>
    <description>Recent content in Posts on 保持热爱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 18 Dec 2020 14:35:37 +0800</lastBuildDate>
    
	<atom:link href="https://metrillin.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Const详解与constexpr</title>
      <link>https://metrillin.github.io/2020/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/</link>
      <pubDate>Fri, 18 Dec 2020 14:35:37 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/</guid>
      <description>const详解 简介 C++中的Const作为从C中继承下来的关键字，名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。
const 基本修饰 C语言中的const仅能维持编译期的值不变性，但是运行时值依然是可变的：
int main(int argc, char *argv) { const int a = 0; // a = 10; // (编译期的const保持)编译错误，因为试图修改一个常量。 // (运行时const属性失效) int *pa = (int *)&amp;amp;a; *pa = 20; // 正确，此时a的值被修改为20，失去常量属性。 return 0; }  由于a = 10编译时会报错，所以编译时屏蔽，运行结果： 可以看到 C中的const只能在编译过程中保持数据不变，还是会被指针修改 为了维持运行时的const语义，c++引入了常量表来记录const对象的名称和值，并将之后所有对const对象的访问修改为访问常量表中的值，以此保证const对象始终如一的常量属性。同时为了保持向下兼容C，C++采取另外一种常量对象的内存分配方式，即： 代码中的const常量并不会立刻分配内存，只有当需要该对象的地址时，才为其分配内存，但从不使用该内存。 同样的代码，让我们使用C++编译器编译 接下来分析编译过程
int main(int argc, char *argv) { const int a = 0; // a成为常量，&amp;lt;a, 0&amp;gt;被保存进入了常量区中，但是并未在栈上为a分配内存。 a = 10; // 编译错误，因为试图修改一个常量。 int *pa = (int *)&amp;amp;a; // 此时，需要常量a的地址，因此编译器被迫在栈上为a分配一块内存。 *pa = 20; // 此时，编译器被迫为a分配的内存被写为20，但是编译器不会使用这块内存。 printf(&amp;quot;a = %d\n&amp;quot;, a); // 但是，每次对a的访问都会去访问常量表，因此a仍然为0，保持了常量属性。 return 0; }  然而，并非所有的常量值都能在编译期被确定。当只有在运行时才能确定常量的值时，该常量将不会进入常量区，仍然保持C语言的运行时不安全的常量属性：</description>
    </item>
    
    <item>
      <title>Ｑｔ操作mysql</title>
      <link>https://metrillin.github.io/2020/qt%E6%93%8D%E4%BD%9Cmysql/</link>
      <pubDate>Mon, 07 Dec 2020 18:12:25 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/qt%E6%93%8D%E4%BD%9Cmysql/</guid>
      <description>[TOC]
1. 基本操作 1.1 添加模块 Qt数据库模块是独立模块，需要像core，gui一样在.pro文件中添加该模块
QT+=sql  1.2 基本操作 获取可用连接 首先查看qt下支持的连接名
qDebug() &amp;lt;&amp;lt; QSqlDatabase::drivers();  输出如下 (&amp;quot;QSQLITE&amp;quot;, &amp;quot;QMYSQL&amp;quot;, &amp;quot;QMYSQL3&amp;quot;, &amp;quot;QPSQL&amp;quot;, &amp;quot;QPSQL7&amp;quot;)
建立连接 使用上一步获取到的连接名作为addDatabase的第一个参数
QSqlDatabase db = QSqlDatabase::addDatabase(&amp;quot;QMYSQL&amp;quot;);  这样我们就获取到mysql的句柄了 接下来是mysql的基本操作
db.setHostName(&amp;quot;localhost&amp;quot;); // 假定数据库在本机 db.setDatabaseName(&amp;quot;student&amp;quot;); // 打开数据库名 db.setUserName(&amp;quot;root&amp;quot;); // 数据库用户名 db.setPassword(&amp;quot;123456&amp;quot;); // 数据库密码  设置完之后调用open()打开mysql数据库,完整代码如下
QSqlDatabase db = QSqlDatabase::addDatabase(&amp;quot;QMYSQL&amp;quot;); db.setHostName(&amp;quot;localhost&amp;quot;); // 假定数据库在本机 db.setDatabaseName(&amp;quot;server&amp;quot;); // 打开数据库名 db.setUserName(&amp;quot;root&amp;quot;); // 数据库用户名 db.setPassword(&amp;quot;123456&amp;quot;); // 数据库密码 if (!db.open()) { qDebug() &amp;lt;&amp;lt; &amp;quot;Failed to connect to root mysql!</description>
    </item>
    
    <item>
      <title>LibCurl编译</title>
      <link>https://metrillin.github.io/2020/libcurl%E7%BC%96%E8%AF%91/</link>
      <pubDate>Sat, 05 Dec 2020 21:30:59 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/libcurl%E7%BC%96%E8%AF%91/</guid>
      <description>libCurl编译 1.首先下载libCurl的源码，这里使用的是Github上的版本
git clone https://github.com/curl/curl.git  或者
git clone https://github.com/curl/curl  2.生成configure
./buildconf  3.查看本地可开启的功能
./configure --enable-pthreads  会显示默认环境下安装后能使用的功能，若是满足需求就直接make和sudo make install
 若要开启SSL support和zlib support:(Centos) yum install openssl-libs openssl-devel 若要支持https需安装libssh2:(Centos) yum install libssh2-devel 若要支持PSL 验证 Cookie 和证书的 Domain 信息，则安装libpsl:(Centos) yum psl libpsl-devel 若要支持HTTP2 ,则安装nghttp2:(Centos) yum install libnghttp2-devel nghttp2 若要支持IDN,则安装libidn:(Centos) yum install libidn2 libidn2-devel 若要支持metalink，则安装 libmetalink:(Centos) yum install libmetalink libmetalink-devel 若要支持RTMP实时流传输，则到官网下载安装,可以参考文章 linux下编译支持librtmp、libx264、libfaac的ffmpeg Ubuntu的可对应上面的centos库自行百度下载   4.编译libcurl 由于本人需要openssl 与SSH2的功能（从上图可以看到SSH为未链接状态，我们可以下载libssh2进行编译） 编译OpenssH（可选）
wget http://www.</description>
    </item>
    
    <item>
      <title>编译android对应版本的openssl</title>
      <link>https://metrillin.github.io/2020/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/</link>
      <pubDate>Thu, 05 Nov 2020 20:29:23 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/</guid>
      <description>编译android对应版本的openssl 版本 自行下载需要的NDK与openssl
NDK: android-ndk-r15c openssl：openssl-1.0.2  下载交叉编译文件 #拉取setenv-android.sh，我们需要这个脚本来给我们配置环境 wget https://wiki.openssl.org/images/7/70/Setenv-android.sh  配置脚本 armv7a版本配置 _ANDROID_NDK=&amp;quot;android-ndk-r9&amp;quot; # 修改为： _ANDROID_NDK=&amp;quot;android-ndk-r15c&amp;quot; # 因为我们使用的是R14B这个版本的NDK  _ANDROID_EABI=&amp;quot;arm-linux-androideabi-4.8&amp;quot; 修改为GCC 4.9 _ANDROID_EABI=&amp;quot;arm-linux-androideabi-4.9&amp;quot;  arm64V8A版本配置 _ANDROID_NDK=&amp;quot;android-ndk-r9&amp;quot; # 修改为： _ANDROID_NDK=&amp;quot;android-ndk-r15c&amp;quot; # 因为我们使用的是r15c这个版本的NDK  _ANDROID_EABI=&amp;quot;arm-linux-androideabi-4.8&amp;quot; 修改为GCC 4.9 _ANDROID_EABI=&amp;quot;aarch64-linux-android-4.9&amp;quot; _ANDROID_ARCH=arch-arm 修改为 _ANDROID_ARCH=arch-arm64  编译 添加环境变量（仅在当前终端就可以了
export ANDROID_NDK_ROOT=/home/ubuntu/android-ndk-r15c source ./Setenv-android.sh  FIPS_SIG的Error无所谓，本次不会使用到这个组件</description>
    </item>
    
    <item>
      <title>Opencv视频流处理方法</title>
      <link>https://metrillin.github.io/2020/opencv%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 15 Oct 2020 18:27:07 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/opencv%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</guid>
      <description>opencv视频流处理方法 OpenCV提供了VideoCapture类和VideoWriter类来支持各种格式的视频流，支持的格式类型会因系统的不同而有所变化，但基本上都是支持avi格式的，且对于视频文件和摄像头画面的读写所用到的接口基本上都相同，因此，我们把它们放在一起来讲了。
1. 获取VideoCapture类实例
不管是读取视频文件还是捕获摄像头画面，都使用到了VideoCapture类，但不同的是传入的形参不一样，如果我们传给VideoCapture类的是一个视频文件路径那么将是读取来自视频文件的画面，而如果我们传给VideoCapture类的是摄像头编号那么将是读取来自摄像头的画面，其使用示例如下：
# 获取VideoCapture类实例，读取视频文件 fcap = cv2.VideoCapture(&#39;demo.mp4&#39;) # 读取摄像头画面 ccap = cv2.VideoCapture(0)  对于摄像头编号，可以使用如下命令获取：
ls -al /dev/ | grep video  对于输出信息以video开头的其数字后缀即为可能的摄像头编号，如果一台电脑有多个摄像头设备，那么将会出现从0开始的多个摄像头编号。
2. 判断获取VideoCapture实例是否成功
如果传入无效的视频文件或摄像头编号，那么VideoCapture类将会在后续的read()接口返回（False，None），为了避免此类事件发生，可以通过VideoCapture类的isOpened()接口进行判断，该接口返回一个boolean值，正常获取实例返回True，否则返回False，其使用示例如下：
# 判断是否正确获取VideoCapture类实例 while fcap.isOpened(): # next step operation  3. 获取视频流信息
一般视频流主要的帧信息包含画面宽高还有帧率，对于视频文件，则会多出整个视频流多少帧，因此，我们一般主要关注这四个视频流信息即可，而我们用到的则是VideoCapture类的get接口，其使用示例如下：
# 获取视频帧的宽 w = fcap.get(cv2.CAP_PROP_FRAME_WIDTH) # 获取视频帧的高 h = fcap.get(cv2.CAP_PROP_FRAME_HEIGHT) # 获取视频帧的帧率 fps = fcap.get(cv2.CAP_PROP_FPS)  获取到的帧率对于摄像头设备来说，如果所使用的终端不支持查询，那么将会返回0值，且该值也不是非常精确的。
# 获取视频流的总帧数 fcount = fcap.get(cv2.CAP_PROP_FRAME_COUNT)  注意这个是对视频文件才有意义，对于摄像头是没意义的，且以上获取到的返回信息均是浮点型的，注意转换为整型。
4. 获取帧画面
这个就相对简单，直接使用VideoCapture类的read接口即可，该接口会返回两个参数，第一个参数是读取成功与否标志位，成功为True否则为False，第二个参数则为具体的帧数据，其是一个numpy.ndarray的数组，其使用示例如下：
# 获取帧画面 success, frame = fcap.</description>
    </item>
    
    <item>
      <title>VLC编译</title>
      <link>https://metrillin.github.io/2020/vlc%E7%BC%96%E8%AF%91/</link>
      <pubDate>Sat, 05 Sep 2020 21:24:17 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/vlc%E7%BC%96%E8%AF%91/</guid>
      <description>VLC编译 git clone git://github.com/vlc-qt/vlc-qt.git sudo apt install libvlc-dev sudo apt-get install snapd sudo apt-get install snapcraft sudo snap install vlc export QTDIR=/Qt安装路径/5.12.3/gcc_64 export LD_LIBRARY_PATH=$QTDIR/lib export PATH=$PATH:$QTDIR/bin sudo cmake .. -DCMAKE_BUILD_TYPE=Debug sudo make -j8 sudo make install  core libvlc error: No plugins found! Check your VLC installation. VLC-Qt Error: libvlc failed to load! sudo apt-get install libvlc-dev sudo apt-get install vlc  CMake Error at config/Dependencies.cmake:28 (FIND_PACKAGE): By not providing &amp;quot;FindQt5Core.</description>
    </item>
    
    <item>
      <title>Docker实例</title>
      <link>https://metrillin.github.io/2020/docker%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Tue, 05 May 2020 21:21:43 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/docker%E5%AE%9E%E4%BE%8B/</guid>
      <description>[TOC]
1. docker实例 下面使用ubuntu:18.04作为例子
1.1. 镜像使用 1.1.1. 获取镜像 docker pull ubuntu:18.04  等待下载完成后,查看宿主机镜像
docker images  我们可以看刚刚下载下来的镜像 1.1.2. 运行镜像 docker run -it ubuntu:18.04 bash  此时我们即启动了该镜像 此处需要说明，每一次使用镜像运行，都会生成一个容器,退出的容器并不会立即删除，除非手动 docker rm,如果不需要排障和保留结果可以使用以下命令
docker run -it --rm ubuntu:18.04 bash   &amp;ndash;rm 参数使docker不会保留该容器，会在容器退出后将其删除
1.1.3. 操作容器 当使用docker run -it ubuntu:18.04 bash会在本地生成一个容器，容器和镜像的关系相当于对象和类，查看本地容器
docker ps -a  启动一个已经停止的容器
docker start b8ed1b0ee812 //containerID/name  捕获一个正在运行的容器，使其转到前台bash
docker attach b8ed1b0ee812 //containerID/name  attach捕获后推出容器，此容器会停止，如果想推出后继续在后台运行使用exec命令
docker exec -it b8ed1b0ee812 /bin/bash  1.</description>
    </item>
    
    <item>
      <title>Docker常用命令</title>
      <link>https://metrillin.github.io/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 06 Apr 2020 21:19:44 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>docker常用命令 示例 1.helloworld的调用 从仓库将image抓取到本地
docker image pull library/hello-world  docker image pull是抓取image文件的命令。ibrary/hello-world是镜像文件在仓库的位置，其中library是image文件所在的组，hello-world是 image 文件的名字。
获得管理员权限（对宿主机的访问）
docker run -it --privileged --rm ubuntu:18.04 bash  查看本地镜像文件:
docker image ls  运行镜像，会生成一个容器实例，镜像和容器的关系就像是类和对象的关系。 查看当前所有容器 &amp;gt; docker container ls
查看当前电脑所有容器，包括终止运行的容器 &amp;gt; docker container ls &amp;ndash;all
终止运行的容器文件，依然会占据硬盘空间，下面是删除指令 &amp;gt; docker container rm [containerID]
除过以上我们使用的Docker命令外，Docker还有一些其它常用的命令
拉取docker镜像
docker pull image_name  设置docker开机自启动
systemctl enable docker  从镜像中构建容器
docker run -it ubuntu:18.04 bash  从镜像中构建容器，退出容器后不保留容器
docker run -it --rm ubuntu:18.</description>
    </item>
    
    <item>
      <title>Docker安装</title>
      <link>https://metrillin.github.io/2020/docker%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sun, 05 Apr 2020 21:18:19 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/docker%E5%AE%89%E8%A3%85/</guid>
      <description>docker安装 ## 安装
1.卸载旧版本 Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。如果已安装，请卸载它们：
sudo apt-get remove docker docker-engine docker.io containerd runc  2.使用 APT 安装 sudo apt-get update  安装 apt 依赖包，用于通过HTTPS来获取仓库:
sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ gnupg-agent \ software-properties-common  为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥 添加 Docker 的官方 GPG 密钥：
$ curl \-fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt\-key add \-  9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。</description>
    </item>
    
  </channel>
</rss>