<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>保持热爱 on 保持热爱</title>
    <link>https://metrillin.github.io/</link>
    <description>Recent content in 保持热爱 on 保持热爱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 18 Dec 2020 14:35:37 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Const详解与constexpr</title>
      <link>https://metrillin.github.io/2020/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/</link>
      <pubDate>Fri, 18 Dec 2020 14:35:37 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/</guid>
      <description>

&lt;h1 id=&#34;const详解&#34;&gt;const详解&lt;/h1&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;C++中的Const作为从C中继承下来的关键字，名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。&lt;/p&gt;

&lt;h2 id=&#34;const-基本修饰&#34;&gt;const 基本修饰&lt;/h2&gt;

&lt;p&gt;C语言中的&lt;strong&gt;const仅能维持编译期的值不变性，但是运行时值依然是可变&lt;/strong&gt;的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main(int argc, char *argv)
{
    const int a = 0;
   // a = 10; // (编译期的const保持)编译错误，因为试图修改一个常量。
    
    // (运行时const属性失效)
    int *pa = (int *)&amp;amp;a;
    *pa = 20; // 正确，此时a的值被修改为20，失去常量属性。
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于a = 10编译时会报错，所以编译时屏蔽，运行结果：
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1608274931_20201007153902896_20433.png&#34; alt=&#34;&#34; /&gt;
可以看到 C中的const只能在编译过程中保持数据不变，还是会被指针修改
为了维持运行时的&lt;code&gt;const&lt;/code&gt;语义，c++引入了常量表来记录const对象的名称和值，并将之后所有对const对象的访问修改为访问常量表中的值，以此保证const对象始终如一的常量属性。同时为了保持向下兼容C，C++采取另外一种常量对象的内存分配方式，即： &lt;strong&gt;代码中的const常量并不会立刻分配内存，只有当需要该对象的地址时，才为其分配内存，但从不使用该内存。&lt;/strong&gt;
同样的代码，让我们使用C++编译器编译
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1608274932_20201007154258305_7497.png&#34; alt=&#34;&#34; /&gt;
接下来分析编译过程&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main(int argc, char *argv)
{
    const int a = 0; // a成为常量，&amp;lt;a, 0&amp;gt;被保存进入了常量区中，但是并未在栈上为a分配内存。
    a = 10; // 编译错误，因为试图修改一个常量。
    int *pa = (int *)&amp;amp;a; // 此时，需要常量a的地址，因此编译器被迫在栈上为a分配一块内存。
    *pa = 20; // 此时，编译器被迫为a分配的内存被写为20，但是编译器不会使用这块内存。
    printf(&amp;quot;a = %d\n&amp;quot;, a); // 但是，每次对a的访问都会去访问常量表，因此a仍然为0，保持了常量属性。
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，并非所有的常量值都能在编译期被确定。当只有在运行时才能确定常量的值时，该常量将不会进入常量区，仍然保持C语言的运行时不安全的常量属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int situation1()
{
    int v = 0;
    const int a = v; // 编译期间无法确定a的值，因此a不会进入常量区。
    a = 10; // 编译错误，因为试图修改一个常量。

    int *pa = (int *)&amp;amp;a; // 取得了真正a变量的地址。
    *pa = 20; // 此时a的值被修改为20，失去常量属性。
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int situation2()
{
    const volatile int a = 0; // 编译期间无法确定a的值，因此a不会进入常量区。
    a = 10; // 编译错误，因为试图修改一个常量。
    int *pa = (int *)&amp;amp;a; // 取得了真正a变量的地址。
    *pa = 20; // 此时a的值被修改为20，失去常量属性。
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果赋值号两边的数据类型不同，那么将会产生&lt;code&gt;类型截断&lt;/code&gt;，此时const也会失去常量语义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int situation3()
{
    const long a = 0; // a成为常量，&amp;lt;a, 0&amp;gt;被保存进入了常量区中，但是并未在栈上为a分配内存。
    const int b = a; // 发生了类型截断，因此即便编译期可以确定值，也不会进入常量表。
    int *pb = (int *)&amp;amp;b; // 取得了真正a变量的地址。
    *pb = 20; // 此时b的值被修改为20，失去常量属性。
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;const修饰指针&#34;&gt;const修饰指针&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;const&lt;/code&gt;用于指针时，其行为和C语言中基本一致。例如，&lt;code&gt;顶层const&lt;/code&gt;表示指针不能再指向其它地址，&lt;code&gt;底层const&lt;/code&gt;保证目前指向的地址中的数据不可被修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main(int argc, char *argv[])
{
    const int *a = nullptr; // 底层const，表示地址中的数据不可被修改(修饰指针指向的地址)
    int *const b = nullptr; // 顶层const，表示指针不能指向其它位置。(修饰指针变量)
    const int *const c = nullptr; // 顶层和底层const，表示指针不能指向其它位置，
    							  // 并且地址中的数据不可被修改。(修饰指针指向的地址与指针变量)
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;const修饰引用&#34;&gt;const修饰引用&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;const引用&lt;/code&gt;没有顶层和底层之分，所有的&lt;code&gt;const引用&lt;/code&gt;都是底层的。当针对左值引用使用&lt;code&gt;const&lt;/code&gt;时，其行为如同C语言中的&lt;code&gt;const&lt;/code&gt;一样，会产生一个新的编译期常量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main(int argc, char *argv[])
{
    const int &amp;amp;a = 0;
    a = 10; // 编译错误，因为试图修改一个常量。
    int *pa = (int *)&amp;amp;a;
    *pa = 20; // 正确，a的值被修改为20.
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;右值不能绑定到左值引用上，但是可以绑定到常量左值引用上，这是因为它可以保证部分右值的不可修改属性。同理，从语义上来看，没有必要使用&lt;code&gt;const&lt;/code&gt;修饰右值引用。&lt;/p&gt;

&lt;h2 id=&#34;const修饰函数&#34;&gt;const修饰函数&lt;/h2&gt;

&lt;p&gt;在类的方法声明中使用&lt;code&gt;const&lt;/code&gt;，则表示这个方法不会导致当前对象的改变；同时，为了保持对象的常量属性，&lt;code&gt;const对象&lt;/code&gt;只能调用&lt;code&gt;const方法&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Object
{
    int _value;
public:
    Object(int value) : _value(value) {}
    int get_value() const { return _value; }
    void set_value(int value) { _value = value; }
};

int main(int argc, char *argv[])
{
    Object o1(10);
    o1.get_value(); // 正确, 10
    o1.set_value(20); // 正确

    const Object o2(10);
    o2.get_value(); // 正确, 10
    o2.set_value(20); // 错误，const对象只能调用const方法。
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;c-11-constexpr-常量表达式&#34;&gt;C++11 constexpr（常量表达式）&lt;/h2&gt;

&lt;p&gt;C++11引进了constexpr函数，目的是将运算尽量放在编译阶段，而不是运行阶段。&lt;strong&gt;const 变量的初始化可以延迟到运行时(见上文)，而 constexpr 变量必须在编译时进行初始化。&lt;/strong&gt; 所有constexpr对象都是const的，但是不是所有的const对象都是constexpr的。&lt;/p&gt;

&lt;p&gt;事实上const并不能代表“常量”，它仅仅是对变量的一个修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过堆栈溢出等方式修改）。而这个变量的值，可以在运行时也可以在编译时指定&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;     int a3 = 5;                        // a3不是常量表达式
     constexpr int a4 = a3;     // a4不是常量表达式，因为a3程序的执行到达其所在的声明处时才初始化
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;constexpr修饰函数&#34;&gt;constexpr修饰函数&lt;/h3&gt;

&lt;p&gt;constexpr函数是指能用于常量表达式的函数。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数的返回类型以及所有形参的类型都得是字面值类型&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数体中必须有且仅有一条return语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;constexpr int lab(int i)
{

return  i*10;
}
int main()
{
int i ;
constexpr int a = lab(i); // Error   the value of &#39;i&#39; is not usable in a constant expression (i不是一个字面值类型)
constexpr int b = lab(10);//Success  形参为非字面值类型,但是实参为字面值类型，编译器会对其优化
return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，执行上述函数时，编译器会对constexpr函数的调用替换成其结果值，为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。既然内联函数，我们就需要遵守内联函数的规则即将 &lt;strong&gt;constexpr函数定义在头文件中&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;constexpr-修饰构造函数&#34;&gt;constexpr 修饰构造函数&lt;/h3&gt;

&lt;p&gt;尽管构造函数不能是const的，但是&lt;strong&gt;字面值常量类&lt;/strong&gt;的构造函数可以是constexpr函数。&lt;/p&gt;

&lt;h4 id=&#34;字面值常量类&#34;&gt;字面值常量类&lt;/h4&gt;

&lt;p&gt;数据成员都是字面值类型的聚合类是字面值常量类，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct Person
{
	std::string name;
	int height;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;聚合类条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有成员都是public&lt;/li&gt;
&lt;li&gt;没有定义构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类，也没有虚函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果一个类不是聚合类，成为一个字面值常量类符合的要求：
*   数据成员都必须是字面值类型。
*   类必须至少含有一个 constexpr 构造函数。
*   如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式。或者如果成员属于某种类类型，则初始值必须使用成员自己的 constexpr 构造函数。
*   类必须使用析构函数的默认定义，该成员负责销毁对象。&lt;/p&gt;

&lt;p&gt;示例类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Debug {
private:
    bool hw;
    bool io;
    bool other;
public:
    constexpr Debug(bool b = true) :hw(b), io(b), other(b) {}
    constexpr Debug(bool h, bool i, bool o) : hw(h), io(i), other(o) {}
    constexpr bool any()const { return hw || io || other; }
    void set_io(bool b) { io = b; }
    void set_hw(bool b) { hw = b; }
    void set_other(bool b) { other = b; }
};

int main()
{
    constexpr Debug io_sub(false, true, false); //调试IO
    if (io_sub.any())                           //等价于if(true)
        cerr &amp;lt;&amp;lt; &amp;quot;print appropriate error messages&amp;quot; &amp;lt;&amp;lt; endl;
    constexpr Debug prod(false);                //无调试
    if (prod.any())                             //等价于if(false)
        cerr &amp;lt;&amp;lt; &amp;quot;print an error message&amp;quot; &amp;lt;&amp;lt; endl;

    

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字面值常量类与字面值类型的用法相同，字面值常量类同样也会在编译期进行计算。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ｑｔ操作mysql</title>
      <link>https://metrillin.github.io/2020/qt%E6%93%8D%E4%BD%9Cmysql/</link>
      <pubDate>Mon, 07 Dec 2020 18:12:25 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/qt%E6%93%8D%E4%BD%9Cmysql/</guid>
      <description>

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;1-基本操作&#34;&gt;1. 基本操作&lt;/h1&gt;

&lt;h2 id=&#34;1-1-添加模块&#34;&gt;1.1 添加模块&lt;/h2&gt;

&lt;p&gt;Qt数据库模块是独立模块，需要像core，gui一样在.pro文件中添加该模块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;QT+=sql
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;1-2-基本操作&#34;&gt;1.2 基本操作&lt;/h1&gt;

&lt;h2 id=&#34;获取可用连接&#34;&gt;获取可用连接&lt;/h2&gt;

&lt;p&gt;首先查看qt下支持的连接名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;qDebug() &amp;lt;&amp;lt; QSqlDatabase::drivers();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下
&lt;code&gt;(&amp;quot;QSQLITE&amp;quot;, &amp;quot;QMYSQL&amp;quot;, &amp;quot;QMYSQL3&amp;quot;, &amp;quot;QPSQL&amp;quot;, &amp;quot;QPSQL7&amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;建立连接&#34;&gt;建立连接&lt;/h2&gt;

&lt;p&gt;使用上一步获取到的连接名作为&lt;strong&gt;&lt;em&gt;addDatabase&lt;/em&gt;&lt;/strong&gt;的第一个参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;QSqlDatabase db = QSqlDatabase::addDatabase(&amp;quot;QMYSQL&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就获取到mysql的句柄了
接下来是mysql的基本操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    db.setHostName(&amp;quot;localhost&amp;quot;);  // 假定数据库在本机
    db.setDatabaseName(&amp;quot;student&amp;quot;); // 打开数据库名
    db.setUserName(&amp;quot;root&amp;quot;);  // 数据库用户名
    db.setPassword(&amp;quot;123456&amp;quot;);  // 数据库密码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置完之后调用open()打开mysql数据库,完整代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    QSqlDatabase db = QSqlDatabase::addDatabase(&amp;quot;QMYSQL&amp;quot;);
    db.setHostName(&amp;quot;localhost&amp;quot;);  // 假定数据库在本机
    db.setDatabaseName(&amp;quot;server&amp;quot;); // 打开数据库名
    db.setUserName(&amp;quot;root&amp;quot;);  // 数据库用户名
    db.setPassword(&amp;quot;123456&amp;quot;);  // 数据库密码
    if (!db.open())
    {
        qDebug() &amp;lt;&amp;lt; &amp;quot;Failed to connect to root mysql!&amp;quot;;
    }
    else
    {
        qDebug() &amp;lt;&amp;lt; &amp;quot;open success!&amp;quot;;
    }
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;增删改查&#34;&gt;增删改查&lt;/h2&gt;

&lt;p&gt;数据库操作无非增删改查，基于我们获取到的句柄，我们可以对数据库进行操作。&lt;/p&gt;

&lt;p&gt;QSqlQuery类提供了一种执行和操作SQL语句的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;QSqlQuery sqlquery(db);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入数据Demo&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    //插入新数据
    QSqlQuery sql_query(db);
    sql_query.prepare(&amp;quot;insert into stu(name,stuID,sex,score) values(&#39;stu2&#39;,&#39;123123&#39;,&#39;1&#39;,&#39;&#39;70)&amp;quot;);
    if(!sql_query.exec())
    {
       qDebug()&amp;lt;&amp;lt;sql_query.lastError();
    }
    else
    {
        qDebug()&amp;lt;&amp;lt;&amp;quot;insert Success...&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询Demo&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    QSqlQuery sql_query(db);
    sql_query.prepare(&amp;quot;select * from stu&amp;quot;);
    if(!sql_query.exec())
    {
       qDebug()&amp;lt;&amp;lt;sql_query.lastError();
    }
    else
    {
       while(sql_query.next())
        {
           QString name = sql_query.value(&amp;quot;name&amp;quot;).toString();
           QString id = sql_query.value(&amp;quot;stuID&amp;quot;).toString();
           QString sex = sql_query.value(&amp;quot;sex&amp;quot;).toString();
            QString score = sql_query.value(&amp;quot;score&amp;quot;).toString();
            qDebug()&amp;lt;&amp;lt;QString(&amp;quot;Name:%1     ID:%2    sex:%3    score:%4&amp;quot;).arg(name).arg(id).arg(sex).arg(score);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329730_20200403142349526_31331.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-3-批量使用&#34;&gt;1.3 批量使用&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;2-driver-not-loaded错误处理&#34;&gt;2. driver not loaded错误处理&lt;/h1&gt;

&lt;h2 id=&#34;问题排查&#34;&gt;问题排查&lt;/h2&gt;

&lt;p&gt;第一次使用Qtmysql的库时容易看到qDebug有如下打印&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;QSqlDatabase: QMYSQL driver not loaded
QSqlDatabase: available drivers: QSQLITE QMYSQL QMYSQL3 QPSQL QPSQL7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329726_20200402173143995_5048.png&#34; alt=&#34;clipboard&#34; /&gt;
查看本机mysql，发现mysqlClient库安装正常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ls /usr/lib/x86_64-linux-gnu/libmysql* -lsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329727_20200403101104397_31787.png&#34; alt=&#34;&#34; /&gt;
查看Qt数据组件sql是否正常
1）进入到Qt的安装目录下，进入对应编译器文件夹中，楼主的文件夹是
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329728_20200403101412861_21234.png&#34; alt=&#34;&#34; /&gt;
查看&lt;strong&gt;libqsqlmysql.so&lt;/strong&gt;文件链接是否正常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ldd libqsqlmysql.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329728_20200403101545125_14714.png&#34; alt=&#34;&#34; /&gt;
结果发现Qt中mysql库链接的是18的版本，而当前环境没有该版本的mysql库&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;h3 id=&#34;1-下载对应版本的libsqlclient&#34;&gt;1.下载对应版本的libsqlclient&lt;/h3&gt;

&lt;p&gt;这个方式比较方便，适合绝大多数场景
* 下载地址： &lt;a href=&#34;https://launchpad.net/ubuntu/xenial/amd64/libmysqlclient18/5.6.25-0ubuntu1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://launchpad.net/ubuntu/xenial/amd64/libmysqlclient18/5.6.25-0ubuntu1&lt;/a&gt;
* 下载 libmysqlclient18_5.6.25-0ubuntu1_amd64.deb，然后 dpkg -i libmysqlclient18_5.6.25-0ubuntu1_amd64.deb 即可。&lt;/p&gt;

&lt;h3 id=&#34;2-重新编译qt中的libqsqlmysql库&#34;&gt;2.重新编译Qt中的libqsqlmysql库&lt;/h3&gt;

&lt;p&gt;进入安装时下载的Qt源码，在对应版本的SRC文件夹下，对该库的源码进行重新编译
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329729_20200403102316916_2297.png&#34; alt=&#34;&#34; /&gt;
最后将编译好的libqsqlmysql.so库放回原先的位置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LibCurl编译</title>
      <link>https://metrillin.github.io/2020/libcurl%E7%BC%96%E8%AF%91/</link>
      <pubDate>Sat, 05 Dec 2020 21:30:59 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/libcurl%E7%BC%96%E8%AF%91/</guid>
      <description>

&lt;h1 id=&#34;libcurl编译&#34;&gt;libCurl编译&lt;/h1&gt;

&lt;p&gt;1.首先下载libCurl的源码，这里使用的是Github上的版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;git clone https://github.com/curl/curl.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;git clone https://github.com/curl/curl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.生成configure&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt; ./buildconf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.查看本地可开启的功能&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;./configure --enable-pthreads
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会显示默认环境下安装后能使用的功能，若是满足需求就直接make和sudo make install&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若要开启SSL support和zlib support:(Centos) yum install openssl-libs openssl-devel&lt;/li&gt;
&lt;li&gt;若要支持https需安装libssh2:(Centos) yum install libssh2-devel&lt;/li&gt;
&lt;li&gt;若要支持PSL 验证 Cookie 和证书的 Domain 信息，则安装libpsl:(Centos) yum psl libpsl-devel&lt;/li&gt;
&lt;li&gt;若要支持HTTP2 ,则安装nghttp2:(Centos) yum install libnghttp2-devel nghttp2&lt;/li&gt;
&lt;li&gt;若要支持IDN,则安装libidn:(Centos) yum install libidn2 libidn2-devel&lt;/li&gt;
&lt;li&gt;若要支持metalink，则安装 libmetalink:(Centos) yum install libmetalink libmetalink-devel&lt;/li&gt;
&lt;li&gt;若要支持RTMP实时流传输，则到官网下载安装,可以参考文章 &lt;a href=&#34;https://blog.csdn.net/dc_show/article/details/47130639&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;linux下编译支持librtmp、libx264、libfaac的ffmpeg&lt;/a&gt;
&lt;strong&gt;Ubuntu的可对应上面的centos库自行百度下载&lt;/strong&gt;
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609853471_20201221102836019_8153.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4.编译libcurl
由于本人需要openssl 与SSH2的功能（从上图可以看到SSH为未链接状态，我们可以下载libssh2进行编译）
&lt;strong&gt;编译OpenssH（可选）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt; wget http://www.libssh2.org/download/libssh2-1.4.3.tar.gz
 tar -zxvf libssh2-1.4.3.tar.gz
 cd libssh2-1.4.3/
//由于我/usr/local的openssl版本太高了，编译会报错，所以使用低版本的openssl
 ./configure --prefix=/usr/local/libssh2 --with-openssl CPPFLAGS=&amp;quot;-I/usr/local/openssl/include&amp;quot; LDFLAGS=&amp;quot;-L/usr/local/openssl/lib&amp;quot;
make
make insatll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将openssh与openssl链接到libcurl中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;进入libcurl文件夹
./configure --prefix=/home/lin/libcurl/outputFile --enable-debug --with-openssl CPPFLAGS=&amp;quot;-I/home/lin/openssl/include&amp;quot; LDFLAGS=&amp;quot;-L/home/lin/openssl/lib&amp;quot; --with-libssh2 CPPFLAGS=&amp;quot;-I/usr/local/libssh2/include&amp;quot; LDFLAGS=&amp;quot;-L//usr/local/libssh2/lib&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到openssh的功能已经支持。
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609853471_20201221114118426_23030.png&#34; alt=&#34;&#34; /&gt;
需要其他的功能也是同理，这里就不展开讲了。&lt;/p&gt;

&lt;p&gt;5.编译与安装
接下来就是make与makeinstall了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;make -j4 
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看设置输出的outputFile文件夹，已经编译成功
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609853472_20201221134804756_1652.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编译android对应版本的openssl</title>
      <link>https://metrillin.github.io/2020/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/</link>
      <pubDate>Thu, 05 Nov 2020 20:29:23 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/</guid>
      <description>

&lt;h1 id=&#34;编译android对应版本的openssl&#34;&gt;编译android对应版本的openssl&lt;/h1&gt;

&lt;h2 id=&#34;版本&#34;&gt;版本&lt;/h2&gt;

&lt;p&gt;自行下载需要的NDK与openssl&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NDK: android-ndk-r15c
openssl：openssl-1.0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;下载交叉编译文件&#34;&gt;下载交叉编译文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#拉取setenv-android.sh，我们需要这个脚本来给我们配置环境
wget https://wiki.openssl.org/images/7/70/Setenv-android.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置脚本&#34;&gt;配置脚本&lt;/h2&gt;

&lt;h3 id=&#34;armv7a版本配置&#34;&gt;armv7a版本配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;_ANDROID_NDK=&amp;quot;android-ndk-r9&amp;quot;
# 修改为：
_ANDROID_NDK=&amp;quot;android-ndk-r15c&amp;quot;
# 因为我们使用的是R14B这个版本的NDK
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;_ANDROID_EABI=&amp;quot;arm-linux-androideabi-4.8&amp;quot;
修改为GCC 4.9
_ANDROID_EABI=&amp;quot;arm-linux-androideabi-4.9&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609853377_20200914133910597_16954.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;arm64v8a版本配置&#34;&gt;arm64V8A版本配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;_ANDROID_NDK=&amp;quot;android-ndk-r9&amp;quot;
# 修改为：
_ANDROID_NDK=&amp;quot;android-ndk-r15c&amp;quot;
# 因为我们使用的是r15c这个版本的NDK
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;_ANDROID_EABI=&amp;quot;arm-linux-androideabi-4.8&amp;quot;
修改为GCC 4.9
_ANDROID_EABI=&amp;quot;aarch64-linux-android-4.9&amp;quot;

_ANDROID_ARCH=arch-arm
修改为
_ANDROID_ARCH=arch-arm64

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;

&lt;p&gt;添加环境变量（仅在当前终端就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;export ANDROID_NDK_ROOT=/home/ubuntu/android-ndk-r15c
 source ./Setenv-android.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FIPS_SIG的Error无所谓，本次不会使用到这个组件&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Opencv视频流处理方法</title>
      <link>https://metrillin.github.io/2020/opencv%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 15 Oct 2020 18:27:07 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/opencv%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</guid>
      <description>

&lt;h1 id=&#34;opencv视频流处理方法&#34;&gt;opencv视频流处理方法&lt;/h1&gt;

&lt;p&gt;OpenCV提供了VideoCapture类和VideoWriter类来支持各种格式的视频流，支持的格式类型会因系统的不同而有所变化，但基本上都是支持avi格式的，且对于视频文件和摄像头画面的读写所用到的接口基本上都相同，因此，我们把它们放在一起来讲了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 获取VideoCapture类实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不管是读取视频文件还是捕获摄像头画面，都使用到了VideoCapture类，但不同的是传入的形参不一样，如果我们传给VideoCapture类的是一个视频文件路径那么将是读取来自视频文件的画面，而如果我们传给VideoCapture类的是摄像头编号那么将是读取来自摄像头的画面，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    # 获取VideoCapture类实例，读取视频文件
    fcap = cv2.VideoCapture(&#39;demo.mp4&#39;)
    # 读取摄像头画面
    ccap = cv2.VideoCapture(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于摄像头编号，可以使用如下命令获取：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    ls -al /dev/ | grep video
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于输出信息以video开头的其数字后缀即为可能的摄像头编号，如果一台电脑有多个摄像头设备，那么将会出现从0开始的多个摄像头编号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 判断获取VideoCapture实例是否成功&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果传入无效的视频文件或摄像头编号，那么VideoCapture类将会在后续的read()接口返回（False，None），为了避免此类事件发生，可以通过VideoCapture类的isOpened()接口进行判断，该接口返回一个boolean值，正常获取实例返回True，否则返回False，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    # 判断是否正确获取VideoCapture类实例
    while fcap.isOpened():
        # next step operation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. 获取视频流信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般视频流主要的帧信息包含画面宽高还有帧率，对于视频文件，则会多出整个视频流多少帧，因此，我们一般主要关注这四个视频流信息即可，而我们用到的则是VideoCapture类的get接口，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    # 获取视频帧的宽
    w = fcap.get(cv2.CAP_PROP_FRAME_WIDTH)
    # 获取视频帧的高
    h = fcap.get(cv2.CAP_PROP_FRAME_HEIGHT)
    # 获取视频帧的帧率
    fps = fcap.get(cv2.CAP_PROP_FPS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取到的帧率对于摄像头设备来说，如果所使用的终端不支持查询，那么将会返回0值，且该值也不是非常精确的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    # 获取视频流的总帧数
    fcount = fcap.get(cv2.CAP_PROP_FRAME_COUNT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这个是对视频文件才有意义，对于摄像头是没意义的，且以上获取到的返回信息均是浮点型的，注意转换为整型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 获取帧画面&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个就相对简单，直接使用VideoCapture类的read接口即可，该接口会返回两个参数，第一个参数是读取成功与否标志位，成功为True否则为False，第二个参数则为具体的帧数据，其是一个numpy.ndarray的数组，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    # 获取帧画面
    success, frame = fcap.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但在读取过程中，有可能会存在失败的情况出现，一般我们是在第二次读取时放入一个while循环来保障整个读取顺利进行，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    # 判断读取视频流是否成功
    while success:
        success, frame = fcap.read()
        # do something in here

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5. 针对一组或多头摄像头特殊处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当需要同步一组摄像头或一个多头（multihead）摄像头（例如立体摄像头或Kinect）时，read()方法就不太适用了，这时，一般使用grab()和retrieve()方法代替它。对于一组摄像头，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    # 一组摄像头的特殊处理
    success0 = fcap0.grab()
    success1 = fcap1.grab()
    if success0 and success1:
        frame0 = fcap0.retrieve()
        frame1 = fcap1.retrieve()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6. 跳到视频流某一帧&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于视频文件，有时候我们需要直接跳到某一个感兴趣的帧并从该帧开始读取数据，那么可以使用VideoCapture类的set接口，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    # 跳到某一感兴趣帧并从此帧开始读取,如从第360帧开始读取
    fcap.set(cv2.CAP_PROP_POS_FRAMES, 360)
    success, frame = fcap.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;7. 设置摄像头分辨率&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;opencv读取到的摄像头画面大小一般为默认的640x480，但这并不一定满足我们的日常使用要求，比如摄像头支持超高清画面，那么我们就希望能捕获到超高清1920x1080的画面，好在VideoCapture类的set接口为我们提供了相应的功能，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    # 设置摄像头分辨率的高
    fcap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080)
    # 设置摄像头分辨率的宽
    fcap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;8. 获取VideoWriter类实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不管是对视频文件的再存储还是对摄像头画面的保存，都是用到了VideoWriter类，且传入的形参意义是一致的，都需要我们传入保存的文件名包含视频格式、指定视频编解码器、保存视频的帧率以及保存视频的分辨率，一般来说，保存视频的帧率最好与读入的画面的帧率一致，但需要我们进行估计或使用计时器才会比较准确，而分辨率则可以更改，只是要求写入的帧其大小要与分辨率保持一致，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
    writer = cv2.VideoWriter(&#39;output.avi&#39;, cv2.VideoWriter_fourcc(&#39;X&#39;, &#39;V&#39;, &#39;I&#39;, &#39;D&#39;), 30, (1080, 1920))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是，我们必须要为VideoWriter类的构造函数传入所需的参数，且若指定的文件名已存在则会被直接覆盖。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9. VideoWriter类支持的视频编解码器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在构造VideoWriter类实例时，我们必须要指定视频编解码器，那么VideoWriter类都支持哪些视频编解码器呢？我们通过cv2.VideoWriter_fourcc来指定具体使用的编解码器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    &#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;：该选项是一个未压缩的YUV颜色编码，兼容性好，但产生文件较大，文件扩展名为.avi
    &#39;P&#39;,&#39;T&#39;,&#39;M&#39;,&#39;I&#39;：该选项是MPEG-1编码类型，文件扩展名为.avi
    &#39;X&#39;,&#39;V&#39;,&#39;T&#39;,&#39;D&#39;：该选项是MPEG-4编码类型，得到的视频大小处于平均值，文件扩展名为.avi
    &#39;T&#39;,&#39;H&#39;,&#39;E&#39;,&#39;O&#39;：该选项是Ogg Vorbis，文件扩展名为.ogv
    &#39;F&#39;,&#39;L&#39;,&#39;V&#39;,&#39;1&#39;：该选项是一个flash视频，文件扩展名为.flv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般常用的是cv2.VideoWriter_fourcc(&amp;lsquo;X&amp;rsquo;,&amp;lsquo;V&amp;rsquo;,&amp;rsquo;T&amp;rsquo;,&amp;rsquo;D&amp;rsquo;)，mp4编码文件相对小一些，或cv2.VideoWriter_fourcc(&amp;lsquo;I&amp;rsquo;,&amp;lsquo;4&amp;rsquo;,&amp;lsquo;2&amp;rsquo;,&amp;lsquo;0&amp;rsquo;)，文件相对大一些，但为了缩小文件空间我们可能还需要用到ffmpeg工具进一步压缩文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10. 保存帧数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个也很简单，直接使用VideoWriter类的write接口即可，该接口一次可以保存一帧数据到制定文件中，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    # 保存帧数据
    writer.write(frame)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;11. 释放资源&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不管是VideoCapture类还是VideoWriter类，当我们使用完了它们之后，都应该将它们释放掉，避免资源一直被占用，而这两个类都有提供了release()接口给我们，我们只需直接调用即可释放资源，使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    # 释放VideoCapture资源
    fcap.release()
    # 释放VideoWriter资源
    writer.release()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;12. 一个完整的示例代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    # -*- coding: utf-8 -*-
    # /usr/bin/env/python3
    
    &#39;&#39;&#39;use opencv3 to capture video frame, show and save its stream.&#39;&#39;&#39;
    
    import cv2
    
    def stream_processing():
        # 获取VideoCapture类实例，读取视频文件
        fcap = cv2.VideoCapture(&#39;demo.mp4&#39;)
    
        # 设置摄像头分辨率的高
        fcap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080)
        # 设置摄像头分辨率的宽
        fcap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920)
        # 跳到某一感兴趣帧并从此帧开始读取,如从第360帧开始读取
        fcap.set(cv2.CAP_PROP_POS_FRAMES, 360)
    
        # 获取视频帧的宽
        w = fcap.get(cv2.CAP_PROP_FRAME_WIDTH)
        # 获取视频帧的高
        h = fcap.get(cv2.CAP_PROP_FRAME_HEIGHT)
        # 获取视频帧的帧率
        fps = fcap.get(cv2.CAP_PROP_FPS)
        # 获取视频流的总帧数
        fcount = fcap.get(cv2.CAP_PROP_FRAME_COUNT)
        
        # 获取VideoWriter类实例
        writer = cv2.VideoWriter(&#39;output.avi&#39;, cv2.VideoWriter_fourcc(&#39;X&#39;, &#39;V&#39;, &#39;I&#39;, &#39;D&#39;), int(fps), (int(w), int(h)))
    
        # 判断是否正确获取VideoCapture类实例
        while fcap.isOpened():
            # 获取帧画面
            success, frame = fcap.read()
            while success:
                cv2.imshow(&amp;quot;demo&amp;quot;, frame)  ## 显示画面
                # 获取帧画面
                success,frame = fcap.read()
    
                # 保存帧数据
                writer.write(frame)
    
                if (cv2.waitKey(20) &amp;amp; 0xff) == ord(&#39;q&#39;):  ## 等待20ms并判断是按“q”退出，相当于帧率是50hz，注意waitKey只能传入整数，
                    break
            # 释放VideoCapture资源
            fcap.release()
        # 释放VideoWriter资源
        writer.release()
        cv2.destroyAllWindows()  ## 销毁所有opencv显示窗口
    
    
    if __name__ == &amp;quot;__main__&amp;quot;:
        stream_processing()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>VLC编译</title>
      <link>https://metrillin.github.io/2020/vlc%E7%BC%96%E8%AF%91/</link>
      <pubDate>Sat, 05 Sep 2020 21:24:17 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/vlc%E7%BC%96%E8%AF%91/</guid>
      <description>

&lt;h1 id=&#34;vlc编译&#34;&gt;VLC编译&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;git clone git://github.com/vlc-qt/vlc-qt.git
sudo apt install libvlc-dev


sudo apt-get install snapd
sudo apt-get install snapcraft 
sudo snap install vlc


export QTDIR=/Qt安装路径/5.12.3/gcc_64
export LD_LIBRARY_PATH=$QTDIR/lib
export PATH=$PATH:$QTDIR/bin


sudo  cmake .. -DCMAKE_BUILD_TYPE=Debug
sudo make -j8
sudo make install


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;core libvlc error: No plugins found! Check your VLC installation.
VLC-Qt Error: libvlc failed to load!

sudo apt-get install libvlc-dev
sudo apt-get install vlc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;CMake Error at config/Dependencies.cmake:28 (FIND_PACKAGE):
  By not providing &amp;quot;FindQt5Core.cmake&amp;quot; in CMAKE_MODULE_PATH this project has
  asked CMake to find a package configuration file provided by &amp;quot;Qt5Core&amp;quot;, but
  CMake did not find one.
1、打开vlc-qt源码目录下的CMakeLists.txt

2、在SET(PROJECT_DESCRIPTION &amp;quot;VLC-Qt - Qt bindings for libVLC&amp;quot;)下方添加一行

    SET(CMAKE_PREFIX_PATH &amp;quot;/opt/Qt5.6.2/5.6/gcc_64&amp;quot;)

注意一点的是CMAKE_PREFIX_PATH的目录的指向必须是在包含有bin lib include等这些QT的安装目录。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;USB摄像头权限不足时&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
snap connections vlc
查看是否允许访问设备


 snap connect vlc:camera :camera
这将在接口和插槽之间建立连接：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ffmpeg安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;sudo apt-get install -y autoconf automake build-essential git libass-dev libfreetype6-dev libsdl2-dev libtheora-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev pkg-config texinfo wget zlib1g-dev

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Docker实例</title>
      <link>https://metrillin.github.io/2020/docker%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Tue, 05 May 2020 21:21:43 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/docker%E5%AE%9E%E4%BE%8B/</guid>
      <description>

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;1-docker实例&#34;&gt;1. docker实例&lt;/h1&gt;

&lt;p&gt;下面使用ubuntu:18.04作为例子&lt;/p&gt;

&lt;h2 id=&#34;1-1-镜像使用&#34;&gt;1.1. 镜像使用&lt;/h2&gt;

&lt;h3 id=&#34;1-1-1-获取镜像&#34;&gt;1.1.1. 获取镜像&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker pull ubuntu:18.04
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待下载完成后,查看宿主机镜像&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker images 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看刚刚下载下来的镜像
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940599_20200414165447335_17775.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-1-2-运行镜像&#34;&gt;1.1.2. 运行镜像&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker run -it  ubuntu:18.04  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时我们即启动了该镜像
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940600_20200414170404824_23488.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940600_20200414170507937_18320.png&#34; alt=&#34;&#34; /&gt;
此处需要说明，每一次使用镜像运行，都会生成一个容器,退出的容器并不会立即删除，除非手动 docker rm,如果不需要排障和保留结果可以使用以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker run -it  --rm ubuntu:18.04  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;ndash;rm 参数使docker不会保留该容器，会在容器退出后将其删除&lt;/p&gt;

&lt;h3 id=&#34;1-1-3-操作容器&#34;&gt;1.1.3. 操作容器&lt;/h3&gt;

&lt;p&gt;当使用&lt;strong&gt;docker run -it  ubuntu:18.04  bash&lt;/strong&gt;会在本地生成一个容器，容器和镜像的关系相当于对象和类，查看本地容器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker ps -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940600_20200415142739990_7538.png&#34; alt=&#34;&#34; /&gt;
启动一个已经停止的容器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker start b8ed1b0ee812 //containerID/name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;捕获一个正在运行的容器，使其转到前台bash&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker attach b8ed1b0ee812 //containerID/name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;attach捕获后推出容器，此容器会停止，如果想推出后继续在后台运行使用exec命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker exec -it b8ed1b0ee812 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-1-4-网络端口映射&#34;&gt;1.1.4. 网络端口映射&lt;/h3&gt;

&lt;p&gt;当在docker中的服务需要监听宿主机的某些网络应用时，我们使用网络端口映射来达成访问。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker run -itd -p 5000:5000 ubuntu bash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;-p&lt;/strong&gt; 是容器内部端口绑定到指定的主机端口。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;-P&lt;/strong&gt; 是容器内部端口随机映射到主机的高端口。
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940602_20200415150710911_3372.png&#34; alt=&#34;&#34; /&gt;
查看结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940602_20200415150900679_2631.png&#34; alt=&#34;&#34; /&gt;
绑定特殊IP&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker run -itd -p 127.0.0.1:5000:5000 ubuntu bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用udp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker run -itd -p 127.0.0.1:5000:5000/udp ubuntu bash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-1-5-创建镜像&#34;&gt;1.1.5. 创建镜像&lt;/h3&gt;

&lt;p&gt;如果从仓库下载的镜像无法满足我们的使用需求，我们有两种方案修改镜像。
- 使用dockerFile自定义镜像
- 使用commit修改镜像&lt;/p&gt;

&lt;h4 id=&#34;1-1-5-1-commit修改镜像&#34;&gt;1.1.5.1. commit修改镜像&lt;/h4&gt;

&lt;p&gt;有时需要在镜像中安装一些软件，又不需要重新搭建环境，这是可以从已经创建的容器中更新镜像，并且提交这个镜像。就可以得到一个修改过的镜像
进入镜像中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker exec -it b8ed1b0ee812 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子我们对容器进行ping工具安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940600_20200415144915573_7417.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;apt-get install inetutils-ping
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940601_20200415145007590_1471.png&#34; alt=&#34;&#34; /&gt;
此时&lt;strong&gt;ping&lt;/strong&gt;安装完成，使用exit退出容器，使用该容器对镜像进行更新&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker commit -m=&amp;quot;has update&amp;quot; -a=&amp;quot;linjg&amp;quot; b8ed1b0ee812 testimage/pingubuntu:v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各个参数说明:
- &lt;strong&gt;-m&lt;/strong&gt;  提交的描述信息
- &lt;strong&gt;-a&lt;/strong&gt;  作者
- &lt;strong&gt;b8ed1b0ee812&lt;/strong&gt;  容器ID
- &lt;strong&gt;testimage/pingubuntu:v2&lt;/strong&gt;  创建的镜像名&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940601_20200415145244734_18760.png&#34; alt=&#34;&#34; /&gt;
镜像提交成功后我们查看镜像&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940601_20200415145411271_23764.png&#34; alt=&#34;&#34; /&gt;
镜像提交完成
这时候使用该镜像再次生成容器，容器内便会自带ping命令，同理其他程序也可如此操作&lt;/p&gt;

&lt;h4 id=&#34;1-1-5-2-dockerfile定制镜像&#34;&gt;1.1.5.2. dockerFile定制镜像&lt;/h4&gt;

&lt;p&gt;Dockerfile 是一个文本文件，其内包含了一条条的 &lt;strong&gt;指令(Instruction)&lt;/strong&gt;，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。
在一个空白目录中新建一个Dockerfile文件添加内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt; FROM testimage/pingubuntu:v2
 RUN apt-get update
 RUN apt install -y build-essential
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FROM为此dockerfile构建的基础镜像，run指令是用来执行命令行命令。上文例子为安装GCC编译器例子。
此处主要讲制作流程，更多指令请参考docker官方文档:&lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://docs.docker.com/engine/reference/builder/&lt;/a&gt;
保存Dockerfile文件并执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker build -t dockfileimage:v3 .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker会对程序进行构建,等待镜像构建完成
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940602_20200415153616761_23486.png&#34; alt=&#34;&#34; /&gt;
耐心等待构建完成后，即可看到自己定制的docker镜像
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940603_20200415154436105_29555.png&#34; alt=&#34;&#34; /&gt;
生成容器查看是否正常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;docker run -it  --rm dockfileimage:v3  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看插入的gcc环境是否正常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;gcc -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940603_20200415154631898_5299.png&#34; alt=&#34;&#34; /&gt;
构建成功&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker常用命令</title>
      <link>https://metrillin.github.io/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 06 Apr 2020 21:19:44 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>

&lt;h1 id=&#34;docker常用命令&#34;&gt;docker常用命令&lt;/h1&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;h3 id=&#34;1-helloworld的调用&#34;&gt;1.helloworld的调用&lt;/h3&gt;

&lt;p&gt;从仓库将image抓取到本地&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker image pull library/hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;docker image pull&lt;/strong&gt;是抓取image文件的命令。&lt;strong&gt;ibrary/hello-world&lt;/strong&gt;是镜像文件在仓库的位置，其中library是image文件所在的组，hello-world是 image 文件的名字。&lt;/p&gt;

&lt;p&gt;获得管理员权限（对宿主机的访问）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt; docker run -it --privileged  --rm ubuntu:18.04  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看本地镜像文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker image ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行镜像，会生成一个容器实例，镜像和容器的关系就像是类和对象的关系。
查看当前所有容器
&amp;gt; docker container ls&lt;/p&gt;

&lt;p&gt;查看当前电脑所有容器，包括终止运行的容器
&amp;gt; docker container ls &amp;ndash;all&lt;/p&gt;

&lt;p&gt;终止运行的容器文件，依然会占据硬盘空间，下面是删除指令
&amp;gt; docker container rm [containerID]&lt;/p&gt;

&lt;p&gt;除过以上我们使用的Docker命令外，Docker还有一些其它常用的命令&lt;/p&gt;

&lt;p&gt;拉取docker镜像&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker pull image_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置docker开机自启动&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从镜像中构建容器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker run -it  ubuntu:18.04  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从镜像中构建容器，退出容器后不保留容器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker run -it  --rm ubuntu:18.04  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开机自启动容器
docker update &amp;ndash;restart=always xxx&lt;/p&gt;

&lt;p&gt;查看宿主机上的镜像，Docker镜像保存在/var/lib/docker目录下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除镜像&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker rmi  docker.io/tomcat:7.0.77-jre7   或者  docker rmi b39c68b7af30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看当前有哪些容器正在运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看所有容器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker ps -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动、停止、重启容器命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker start container_name/container_id
docker stop container_name/container_id
docker restart container_name/container_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后台启动一个容器后，如果想进入到这个容器，可以使用attach命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker attach container_name/container_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除容器的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker rm container_name/container_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看当前系统Docker信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker info
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从Docker hub上下载某个镜像:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;docker pull centos:latest
docker pull centos:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行docker pull centos会将Centos这个仓库下面的所有镜像下载到本地repository。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker安装</title>
      <link>https://metrillin.github.io/2020/docker%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sun, 05 Apr 2020 21:18:19 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2020/docker%E5%AE%89%E8%A3%85/</guid>
      <description>

&lt;h1 id=&#34;docker安装&#34;&gt;docker安装&lt;/h1&gt;

&lt;p&gt;## 安装&lt;/p&gt;

&lt;h3 id=&#34;1-卸载旧版本&#34;&gt;1.卸载旧版本&lt;/h3&gt;

&lt;p&gt;Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。如果已安装，请卸载它们：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sudo apt-get remove docker docker-engine docker.io containerd runc
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-使用-apt-安装&#34;&gt;2.使用 APT 安装&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 apt 依赖包，用于通过HTTPS来获取仓库:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥
添加 Docker 的官方 GPG 密钥：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp*-&#34;&gt;$ curl \-fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt\-key add \-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;$ sudo apt-key fingerprint 0EBFCD88
   
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) &amp;lt;docker@docker.com&amp;gt;
sub   rsa4096 2017-02-22 [S]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装-docker-engine-community&#34;&gt;安装 Docker Engine-Community&lt;/h2&gt;

&lt;p&gt;安装最新版本的 Docker Engine-Community 和 containerd&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sudo apt-get install docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;修改image-仓库的镜像网址&#34;&gt;修改image 仓库的镜像网址&lt;/h2&gt;

&lt;p&gt;国内访问 Docker 的官方仓库很慢，还经常断线，所以要把仓库网址改成国内的镜像站。
打开/etc/default/docker文件（需要sudo权限)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sudo gedit /etc/default/docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在文件的底部加上一行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;DOCKER_OPTS=&amp;quot;--registry-mirror=https://registry.docker-cn.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，重启 Docker 服务。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;$ sudo service docker restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就会自动从镜像仓库下载 image 文件了。&lt;/p&gt;

&lt;h2 id=&#34;测试-docker-是否安装成功&#34;&gt;测试 Docker 是否安装成功&lt;/h2&gt;

&lt;p&gt;测试 Docker 是否安装成功，输入以下指令，打印出以下信息则安装成功:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sudo docker run hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609852747_20200414151848751_30290.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux内存分布</title>
      <link>https://metrillin.github.io/2019/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</link>
      <pubDate>Tue, 15 Oct 2019 22:11:18 +0800</pubDate>
      
      <guid>https://metrillin.github.io/2019/linux%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</guid>
      <description>

&lt;h1 id=&#34;linux内存分布&#34;&gt;linux内存分布&lt;/h1&gt;

&lt;h2 id=&#34;x86-平台-linux-进程内存布局&#34;&gt;X86 平台 Linux 进程内存布局&lt;/h2&gt;

&lt;h3 id=&#34;什么是虚拟空间&#34;&gt;什么是虚拟空间&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;虚拟空间可以认为是操作系统给每个进程准备的沙盒，就像电影《黑客帝国》中 Matrix 给每个人准备的充满营养液的容器一样。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实际上，每个进程只存活在自己的虚拟世界里，却感觉自己独占了所有的系统资源（内存）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当一个进程要使用某块内存时，它会将自己世界里的一个内存地址告诉操作系统，剩下的事情就由操作系统接管了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;操作系统中的内存管理策略将决定映射哪块真实的物理内存，供应用使用。操作系统会竭尽全力满足所有进程合法的内存访问请求。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一旦发现应用试图访问非法内存，它将会把进程杀死，防止它做“坏事”影响到系统或其他进程。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样做，一方面为了安全，防止进程操作其他进程或者系统内核的数据；另一方面为了保证系统可同时运行多个进程，且单个进程使用的内存空间可以超过实际的物理内存容量。
该做法的另一结果则是降低了每个进程内存管理的复杂度，进程只需关心如何使用自己线性排列的虚拟地址，而不需关心物理内存的实际容量，以及如何使用真实的物理内存。&lt;/p&gt;

&lt;h3 id=&#34;进程内存布局&#34;&gt;进程内存布局&lt;/h3&gt;

&lt;p&gt;在多任务操作系统中的每一个进程都运行在一个属于它自己的内存沙盘中。这个沙盘就是虚拟地址空间（virtual address space），在32位模式下它总是一个4GB的内存地址块。这些虚拟地址通过页表（page table）映射到物理内存，&lt;strong&gt;页表由操作系统维护并被处理器引用。每一个进程拥有一套属于它自己的页表&lt;/strong&gt;，但是还有一个隐情。只要虚拟地址被使能，那么它就会作用于这台机器上运行的所有软件，包括内核本身。因此一部分虚拟地址必须保留给内核使用：
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609855848_20200518142140108_4941.png&#34; alt=&#34;&#34; /&gt;
这并不意味着内核使用了那么多的物理内存，仅表示它可支配这么大的地址空间，可根据内核需要，将其映射到物理内存。内核空间在页表中拥有较高的特权级（ring 2 或以下），因此只要用户态的程序试图访问这些页，就会导致一个页错误（page fault）。在 Linux 中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址的，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化：
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609855849_20200518142208210_26349.png&#34; alt=&#34;&#34; /&gt;
蓝色区域表示映射到物理内存的虚拟地址，而白色区域表示未映射的部分。在上面的例子中，Firefox 使用了相当多的虚拟地址空间，因为它是传说中的吃内存大户。&lt;/p&gt;

&lt;h2 id=&#34;虚拟空间地址排布&#34;&gt;虚拟空间地址排布&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在 32 位系统下，进程的虚拟地址空间有 4G，其中的 1G 分配给了内核空间，用户应用可以使用剩余的 3G。&lt;/li&gt;
&lt;li&gt;在 64 位的 Linux 系统上，进程的虚拟地址空间可以达到 256TB，内核和应用分别占用 128TB。目前看来，这样的地址空间范围足够用了。
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609855849_20200518143831292_24387.png&#34; alt=&#34;&#34; /&gt;
图#1中，《深入程序布局内部》中讨论过的内容，是按照 ELF 文件中的程序头信息，加载文件内容所得到的。除此之外，加载器还会为每个应用分配栈区（Stack）、堆区（Heap）和动态链接库加载区。栈和堆分别向相对的方向增长，系统会有相应的保护措施，阻止越界行为发生。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;栈 - 专门用来存储局部变量，所有的局部变量都是声明在栈区域当中。
堆 - 允许程序员手动的从堆申请空间来使用。程序员可以自己申请指定字节数的空间。
BSS段 - 用来存储未初始化的全局变量和静态变量，声明一个全局变量，如果我们没有初始化，在程序运行最开始的时候，这个变量没有初始化时是存储在BSS段，初始化之后，全局变量和静态变量就会被放到常量区。
数据段/常量区 - 用来存储已经初始化的全局变量、静态变量，还有常量数据
代码段 - 用来存储程序的代码/指令。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查看进程内存排布&#34;&gt;查看进程内存排布&lt;/h3&gt;

&lt;p&gt;在 Linux 系统中，使用如下命令可查看一个运行中的进程的内存排布。
&lt;code&gt;cat /proc/PID/maps&lt;/code&gt;
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609855850_20200518145254095_10450.png&#34; alt=&#34;&#34; /&gt;
从以上输出的内容中，可以直观看到进程的段、堆区，动态链接库加载区，栈区的逻辑地址排布，以及每块内存区分配到的权限等。
除此之外，还有两块 vdso 和 vsyscall 内存区。它们是一部分内核数据在用户空间的映射，为了提高应用的性能而创建。&lt;/p&gt;

&lt;h2 id=&#34;进程的启动&#34;&gt;进程的启动&lt;/h2&gt;

&lt;p&gt;从用户角度来看，启动一个进程有许多种方式，可以配置开机自启动，可以在 Shell 中手动运行，也可以从脚本或其他进程中启动。
而从开发人员角度看，无非就是两个系统调用，即 fork() 和 execve()。下面就来探究下这两个系统调用的行为细节。&lt;/p&gt;

&lt;h3 id=&#34;fork-系统调用&#34;&gt;fork() 系统调用&lt;/h3&gt;

&lt;p&gt;fork() 系统调用将&lt;strong&gt;创建一个与父进程几乎一样的新进程&lt;/strong&gt;，之后继续执行下面的指令。程序可以根据 fork() 的返回值，确定当前处于父进程中，还是子进程中——在父进程中，返回值为新创建子进程的进程 ID，在子进程中，返回值是 0。一些使用多进程模型的服务器程序（比如 sshd），就是通过 fork() 系统调用来实现的，每当新用户接入时，系统就会专门创建一个新进程，来服务该用户。
fork() 系统调用所创建的新进程，与其父进程的内存布局和数据几乎一模一样。在内核中，它们的代码段所在的只读存储区会共享&lt;strong&gt;相同的物理内存页&lt;/strong&gt;。&lt;strong&gt;可读可写的数据段&lt;/strong&gt;、&lt;strong&gt;堆及栈等内存&lt;/strong&gt;，内核会使用&lt;strong&gt;写时复制&lt;/strong&gt;技术，为每个进程独立创建一份。
在 fork() 系统调用刚刚执行完的那一刻，子进程即可拥有一份与父进程完全一样的数据拷贝。对于已打开的文件，内核会增加每个文件描述符的引用计数，每个进程都可以用相同的文件句柄访问同一个文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;深入理解了这些底层行为细节，就可以顺理成章地理解 fork() 的一些行为表现和正确使用规范&lt;/strong&gt;，无需死记硬背，也可获得一些别人踩过坑后才能获得的经验。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;比如&lt;/strong&gt;，使用多进程模型的网络服务程序中，为什么要在子进程中关闭监听套接字，同时要在父进程中关闭新连接的套接字呢？&lt;/p&gt;

&lt;p&gt;原因在于 fork() 执行之后，所有已经打开的套接字都被增加了引用计数，在其中任一个进程中都无法彻底关闭套接字，只能减少该文件的引用计数。因此，在 fork() 之后，每个进程立即关闭不再需要的文件是个好的策略，否则很容易导致大量没有正确关闭的文件一直占用系统资源的现象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;再比如&lt;/strong&gt;，下面这段代码是否存在问题？为什么在输出文件中会出现两行重复的文本？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;int main(){   
    FILE * fp = fopen(&amp;quot;output.txt&amp;quot;, &amp;quot;w&amp;quot;);   
    fputs(&amp;quot;Message in parent\n&amp;quot;, fp);
    switch(fork()) 
    {   
    case -1:     
        perror(&amp;quot;fork failed&amp;quot;);     
        return -1;   
    case 0:      
        fputs(&amp;quot;Message in Child\n&amp;quot;, fp); 
        break;   
    default:   
        break;   
    }    
    fclose(fp); 
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入文本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;[root@TealCode process]# cat output.txt
Message in parent
Message in parent
Message in Child
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因是 fputs 库函数带有缓冲，fork() 创建的子进程完全拷贝父进程用户空间内存时，fputs 库函数的缓冲区也被包含进来了。所以，fork() 执行之后，子进程同样获得了一份 fputs 缓冲区中的数据，导致“Message in parent”这条消息在子进程中又被输出了一次。要解决这个问题，只需在 fork() 之前，利用 fflush 打开文件即可，读者可自行验证。&lt;/p&gt;

&lt;p&gt;另外，希望读者自己思考下，利用父子进程共享相同的只读数据段的特性，是不是可以实现一套父子进程间的通信机制呢？&lt;/p&gt;

&lt;h4 id=&#34;execve-系统调用&#34;&gt;execve() 系统调用&lt;/h4&gt;

&lt;p&gt;execve() 系统调用的作用是&lt;strong&gt;运行另外一个指定的程序&lt;/strong&gt;。它会把新程序加载到当前进程的内存空间内，当前的进程会被丢弃，它的堆、栈和所有的段数据都会被新进程相应的部分代替，然后会从新程序的初始化代码和 main 函数开始运行。同时，进程的 ID 将保持不变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;execve() 系统调用通常与 fork() 系统调用配合使用&lt;/strong&gt;。从一个进程中启动另一个程序时，通常是先 fork() 一个子进程，然后在子进程中使用 execve() 变身为运行指定程序的进程。例如，当用户在 Shell 下输入一条命令启动指定程序时，Shell 就是先 fork() 了自身进程，然后在子进程中使用 execve() 来运行指定的程序。&lt;/p&gt;

&lt;p&gt;execve() 系统调用的函数原型为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;int execve(const char *filename, char *const argv[], char *const envp[]);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;filename 用于指定要运行的程序的文件名，argv 和 envp 分别指定程序的运行参数和环境变量。除此之外，该系列函数还有很多变体，它们执行大体相同的功能，区别在于需要的参数不同，包括 execl、execlp、execle、execv、execvp、execvpe 等。它们的参数意义和使用方法请读者自行查看帮助手册。&lt;/p&gt;

&lt;p&gt;需要注意的是，exec 系列函数的返回值只在遇到错误的时候才有意义。如果新程序成功地被执行，那么当前进程的所有数据就都被新进程替换掉了，所以永远也不会有任何返回值。&lt;/p&gt;

&lt;p&gt;对于已打开文件的处理，在 exec() 系列函数执行之前，&lt;strong&gt;应该确保全部关闭&lt;/strong&gt;。因为 exec() 调用之后，当前进程就完全变身成另外一个进程了，老进程的所有数据都不存在了。如果 exec() 调用失败，当前打开的文件状态应该被保留下来。让应用层处理这种情况会非常棘手，而且有些文件可能是在某个库函数内部打开的，应用对此并不知情，更谈不上正确地维护它们的状态了。&lt;/p&gt;

&lt;p&gt;所以，对于执行 exec() 函数的应用，应该&lt;strong&gt;总是使用内核为文件提供的执行时关闭标志（FD_CLOEXEC）&lt;/strong&gt;。设置了该标志之后，如果 exec() 执行成功，文件就会被自动关闭；如果 exec() 执行失败，那么文件会继续保持打开状态。使用系统调用 fcntl() 可以设置该标志。&lt;/p&gt;

&lt;h4 id=&#34;fexecve-函数&#34;&gt;fexecve() 函数&lt;/h4&gt;

&lt;p&gt;glibc 从 2.3.2 版本开始提供 fexecv() 函数，它与 execve() 的区别在于，&lt;strong&gt;第一个参数使用的是打开的文件描述符，而非文件路径名&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;增加这个函数是为了满足这样的应用需求：有些应用在执行某个程序文件之前，需要先打开文件验证文件内容的校验和，确保文件内容没有被恶意修改过。&lt;/p&gt;

&lt;p&gt;在这种情景下，&lt;strong&gt;使用 fexecve 是更加安全的方案&lt;/strong&gt;。组合使用 open() 和 execve() 虽然可以实现同样的功能，但是在打开文件和执行文件之间，存在被执行的程序文件被掉包的可能性。&lt;/p&gt;

&lt;h3 id=&#34;监控子进程状态&#34;&gt;监控子进程状态&lt;/h3&gt;

&lt;p&gt;在 Linux 应用中，父进程需要监控其创建的所有子进程的退出状态，可以通过如下几个系统调用来实现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pid_t wait(int * statua)&lt;/p&gt;

&lt;p&gt;一直阻塞地等待任意一个子进程退出，返回值为退出的子进程的 ID，status 中包含子进程设置的退出标志。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pid_t waitpid(pid_t pid, int * status, int options)&lt;/p&gt;

&lt;p&gt;可以用 pid 参数指定要等待的进程或进程组的 ID，options 可以控制是否阻塞，以及是否监控因信号而停止的子进程等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;int waittid(idtype_t idtype, id_t id, siginfo_t *infop, int options)&lt;/p&gt;

&lt;p&gt;提供比 waitpid 更加精细的控制选项来监控指定子进程的运行状态。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;wait3() 和 wait4() 系统调用&lt;/p&gt;

&lt;p&gt;可以在子进程退出时，获取到子进程的资源使用数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更详细的信息请参考帮助手册。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文要重点讨论的是：即使父进程在业务逻辑上不关心子进程的终止状态，也需要使用 wait 类系统调用的底层原因。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这其中的要点在于：在 Linux 的内核实现中，允许父进程在子进程创建之后的任意时刻用 wait() 系列系统调用来确定子进程的状态。&lt;/p&gt;

&lt;p&gt;也就是说，如果子进程在父进程调用 wait() 之前就终止了，内核需要保留该子进程的终止状态和资源使用等数据，直到父进程执行 wait() 把这些数据取走。&lt;/p&gt;

&lt;p&gt;在子进程终止到父进程获取退出状态之间的这段时间，这个进程会变成所谓的僵尸状态，在该状态下，任何信号都无法结束它。如果系统中存在大量此类僵尸进程，&lt;strong&gt;势必会占用大量内核资源，甚至会导致新进程创建失败&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果父进程也终止，那么 init 进程会接管这些僵尸进程并自动调用 wait ，从而把它们从系统中移除。但是对于长期运行的服务器程序，这一定不是开发者希望看到的结果。所以，父进程一定要仔细维护好它创建的所有子进程的状态，防止僵尸进程的产生。&lt;/p&gt;

&lt;h3 id=&#34;进程的终止&#34;&gt;进程的终止&lt;/h3&gt;

&lt;p&gt;正常终止一个进程可以用 _exit 系统调用来实现，原型为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;void _exit(int status);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的 status 会返回 wait() 类的系统调用。&lt;strong&gt;进程退出时会清理掉该进程占用的所有系统资源&lt;/strong&gt;，包括关闭打开的文件描述符、释放持有的文件锁和内存锁、取消内存映射等，还会给一些子进程发送信号（后面课程再详细展开）。该系统调用一定会成功，永远不会返回。&lt;/p&gt;

&lt;p&gt;在退出之前，还希望做一些&lt;strong&gt;个性化的清理操作&lt;/strong&gt;，可以使用库函数 exit() 。函数原型为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;void exit(int status);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个库函数先调用退出处理程序，然后再利用 status 参数调用 _exit() 系统调用。这里的退出处理程序可以通过 atexit() 或 on_exit() 函数注册。其中 atexit() 只能注册返回值和参数都为空的回调函数，而 on_exit() 可以注册带参数的回调函数。退出处理函数的执行顺序与注册顺序相反。它们的函数原型如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;int atexit(void (*func)(void));int on_exit(void (*func)(int, void *), void *arg);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常情况下，&lt;strong&gt;个性化的退出处理函数只会在主进程中执行一次&lt;/strong&gt;，所以 exit() 函数一般在主进程中使用，而在子进程中只使用 _exit() 系统调用结束当前进程。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;本文深入探究了 Linux 进程在用户空间的一些内部细节，包括&lt;strong&gt;逻辑内存排布&lt;/strong&gt;、&lt;strong&gt;进程创建和变身的内部细节&lt;/strong&gt;、&lt;strong&gt;进程状态监控的目的和接口&lt;/strong&gt;，以及&lt;strong&gt;终止进程的正确姿势&lt;/strong&gt;等。对这些底层实现细节的充分理解，能帮助读者&lt;strong&gt;更好地理解各个系统调用的行为表现&lt;/strong&gt;，并根据具体的应用需求&lt;strong&gt;选择正确、合适的实现方案&lt;/strong&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://metrillin.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://metrillin.github.io/about/</guid>
      <description>&lt;p&gt;Hugo is the &lt;strong&gt;world’s fastest framework for building websites&lt;/strong&gt;. It is written in Go.&lt;/p&gt;

&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/russross/blackfriday&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/russross/blackfriday&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alecthomas/chroma&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/alecthomas/chroma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/muesli/smartcrop&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/muesli/smartcrop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/spf13/cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/spf13/viper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>