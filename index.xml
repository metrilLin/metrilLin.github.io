<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 18 Dec 2020 14:35:37 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Const详解与constexpr</title>
      <link>/2020/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/</link>
      <pubDate>Fri, 18 Dec 2020 14:35:37 +0800</pubDate>
      
      <guid>/2020/const%E8%AF%A6%E8%A7%A3%E4%B8%8Econstexpr/</guid>
      <description>

&lt;h1 id=&#34;const详解&#34;&gt;const详解&lt;/h1&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;C++中的Const作为从C中继承下来的关键字，名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。&lt;/p&gt;

&lt;h2 id=&#34;const-基本修饰&#34;&gt;const 基本修饰&lt;/h2&gt;

&lt;p&gt;C语言中的&lt;strong&gt;const仅能维持编译期的值不变性，但是运行时值依然是可变&lt;/strong&gt;的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char *argv)
{
    const int a = 0;
   // a = 10; // (编译期的const保持)编译错误，因为试图修改一个常量。
    
    // (运行时const属性失效)
    int *pa = (int *)&amp;amp;a;
    *pa = 20; // 正确，此时a的值被修改为20，失去常量属性。
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于a = 10编译时会报错，所以编译时屏蔽，运行结果：
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1608274931_20201007153902896_20433.png&#34; alt=&#34;&#34; /&gt;
可以看到 C中的const只能在编译过程中保持数据不变，还是会被指针修改
为了维持运行时的&lt;code&gt;const&lt;/code&gt;语义，c++引入了常量表来记录const对象的名称和值，并将之后所有对const对象的访问修改为访问常量表中的值，以此保证const对象始终如一的常量属性。同时为了保持向下兼容C，C++采取另外一种常量对象的内存分配方式，即： &lt;strong&gt;代码中的const常量并不会立刻分配内存，只有当需要该对象的地址时，才为其分配内存，但从不使用该内存。&lt;/strong&gt;
同样的代码，让我们使用C++编译器编译
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1608274932_20201007154258305_7497.png&#34; alt=&#34;&#34; /&gt;
接下来分析编译过程&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char *argv)
{
    const int a = 0; // a成为常量，&amp;lt;a, 0&amp;gt;被保存进入了常量区中，但是并未在栈上为a分配内存。
    a = 10; // 编译错误，因为试图修改一个常量。
    int *pa = (int *)&amp;amp;a; // 此时，需要常量a的地址，因此编译器被迫在栈上为a分配一块内存。
    *pa = 20; // 此时，编译器被迫为a分配的内存被写为20，但是编译器不会使用这块内存。
    printf(&amp;quot;a = %d\n&amp;quot;, a); // 但是，每次对a的访问都会去访问常量表，因此a仍然为0，保持了常量属性。
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，并非所有的常量值都能在编译期被确定。当只有在运行时才能确定常量的值时，该常量将不会进入常量区，仍然保持C语言的运行时不安全的常量属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int situation1()
{
    int v = 0;
    const int a = v; // 编译期间无法确定a的值，因此a不会进入常量区。
    a = 10; // 编译错误，因为试图修改一个常量。

    int *pa = (int *)&amp;amp;a; // 取得了真正a变量的地址。
    *pa = 20; // 此时a的值被修改为20，失去常量属性。
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int situation2()
{
    const volatile int a = 0; // 编译期间无法确定a的值，因此a不会进入常量区。
    a = 10; // 编译错误，因为试图修改一个常量。
    int *pa = (int *)&amp;amp;a; // 取得了真正a变量的地址。
    *pa = 20; // 此时a的值被修改为20，失去常量属性。
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果赋值号两边的数据类型不同，那么将会产生&lt;code&gt;类型截断&lt;/code&gt;，此时const也会失去常量语义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int situation3()
{
    const long a = 0; // a成为常量，&amp;lt;a, 0&amp;gt;被保存进入了常量区中，但是并未在栈上为a分配内存。
    const int b = a; // 发生了类型截断，因此即便编译期可以确定值，也不会进入常量表。
    int *pb = (int *)&amp;amp;b; // 取得了真正a变量的地址。
    *pb = 20; // 此时b的值被修改为20，失去常量属性。
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;const修饰指针&#34;&gt;const修饰指针&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;const&lt;/code&gt;用于指针时，其行为和C语言中基本一致。例如，&lt;code&gt;顶层const&lt;/code&gt;表示指针不能再指向其它地址，&lt;code&gt;底层const&lt;/code&gt;保证目前指向的地址中的数据不可被修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main(int argc, char *argv[])
{
    const int *a = nullptr; // 底层const，表示地址中的数据不可被修改(修饰指针指向的地址)
    int *const b = nullptr; // 顶层const，表示指针不能指向其它位置。(修饰指针变量)
    const int *const c = nullptr; // 顶层和底层const，表示指针不能指向其它位置，
    							  // 并且地址中的数据不可被修改。(修饰指针指向的地址与指针变量)
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;const修饰引用&#34;&gt;const修饰引用&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;const引用&lt;/code&gt;没有顶层和底层之分，所有的&lt;code&gt;const引用&lt;/code&gt;都是底层的。当针对左值引用使用&lt;code&gt;const&lt;/code&gt;时，其行为如同C语言中的&lt;code&gt;const&lt;/code&gt;一样，会产生一个新的编译期常量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main(int argc, char *argv[])
{
    const int &amp;amp;a = 0;
    a = 10; // 编译错误，因为试图修改一个常量。
    int *pa = (int *)&amp;amp;a;
    *pa = 20; // 正确，a的值被修改为20.
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;右值不能绑定到左值引用上，但是可以绑定到常量左值引用上，这是因为它可以保证部分右值的不可修改属性。同理，从语义上来看，没有必要使用&lt;code&gt;const&lt;/code&gt;修饰右值引用。&lt;/p&gt;

&lt;h2 id=&#34;const修饰函数&#34;&gt;const修饰函数&lt;/h2&gt;

&lt;p&gt;在类的方法声明中使用&lt;code&gt;const&lt;/code&gt;，则表示这个方法不会导致当前对象的改变；同时，为了保持对象的常量属性，&lt;code&gt;const对象&lt;/code&gt;只能调用&lt;code&gt;const方法&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Object
{
    int _value;
public:
    Object(int value) : _value(value) {}
    int get_value() const { return _value; }
    void set_value(int value) { _value = value; }
};

int main(int argc, char *argv[])
{
    Object o1(10);
    o1.get_value(); // 正确, 10
    o1.set_value(20); // 正确

    const Object o2(10);
    o2.get_value(); // 正确, 10
    o2.set_value(20); // 错误，const对象只能调用const方法。
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;c-11-constexpr-常量表达式&#34;&gt;C++11 constexpr（常量表达式）&lt;/h2&gt;

&lt;p&gt;C++11引进了constexpr函数，目的是将运算尽量放在编译阶段，而不是运行阶段。&lt;strong&gt;const 变量的初始化可以延迟到运行时(见上文)，而 constexpr 变量必须在编译时进行初始化。&lt;/strong&gt; 所有constexpr对象都是const的，但是不是所有的const对象都是constexpr的。&lt;/p&gt;

&lt;p&gt;事实上const并不能代表“常量”，它仅仅是对变量的一个修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过堆栈溢出等方式修改）。而这个变量的值，可以在运行时也可以在编译时指定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     int a3 = 5;                        // a3不是常量表达式
     constexpr int a4 = a3;     // a4不是常量表达式，因为a3程序的执行到达其所在的声明处时才初始化
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;constexpr修饰函数&#34;&gt;constexpr修饰函数&lt;/h3&gt;

&lt;p&gt;constexpr函数是指能用于常量表达式的函数。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数的返回类型以及所有形参的类型都得是字面值类型&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数体中必须有且仅有一条return语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;constexpr int lab(int i)
{

return  i*10;
}
int main()
{
int i ;
constexpr int a = lab(i); // Error   the value of &#39;i&#39; is not usable in a constant expression (i不是一个字面值类型)
constexpr int b = lab(10);//Success  形参为非字面值类型,但是实参为字面值类型，编译器会对其优化
return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，执行上述函数时，编译器会对constexpr函数的调用替换成其结果值，为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。既然内联函数，我们就需要遵守内联函数的规则即将 &lt;strong&gt;constexpr函数定义在头文件中&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;constexpr-修饰构造函数&#34;&gt;constexpr 修饰构造函数&lt;/h3&gt;

&lt;p&gt;尽管构造函数不能是const的，但是&lt;strong&gt;字面值常量类&lt;/strong&gt;的构造函数可以是constexpr函数。&lt;/p&gt;

&lt;h4 id=&#34;字面值常量类&#34;&gt;字面值常量类&lt;/h4&gt;

&lt;p&gt;数据成员都是字面值类型的聚合类是字面值常量类，例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Person
{
	std::string name;
	int height;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;聚合类条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有成员都是public&lt;/li&gt;
&lt;li&gt;没有定义构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类，也没有虚函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果一个类不是聚合类，成为一个字面值常量类符合的要求：
*   数据成员都必须是字面值类型。
*   类必须至少含有一个 constexpr 构造函数。
*   如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式。或者如果成员属于某种类类型，则初始值必须使用成员自己的 constexpr 构造函数。
*   类必须使用析构函数的默认定义，该成员负责销毁对象。&lt;/p&gt;

&lt;p&gt;示例类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Debug {
private:
    bool hw;
    bool io;
    bool other;
public:
    constexpr Debug(bool b = true) :hw(b), io(b), other(b) {}
    constexpr Debug(bool h, bool i, bool o) : hw(h), io(i), other(o) {}
    constexpr bool any()const { return hw || io || other; }
    void set_io(bool b) { io = b; }
    void set_hw(bool b) { hw = b; }
    void set_other(bool b) { other = b; }
};

int main()
{
    constexpr Debug io_sub(false, true, false); //调试IO
    if (io_sub.any())                           //等价于if(true)
        cerr &amp;lt;&amp;lt; &amp;quot;print appropriate error messages&amp;quot; &amp;lt;&amp;lt; endl;
    constexpr Debug prod(false);                //无调试
    if (prod.any())                             //等价于if(false)
        cerr &amp;lt;&amp;lt; &amp;quot;print an error message&amp;quot; &amp;lt;&amp;lt; endl;

    

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字面值常量类与字面值类型的用法相同，字面值常量类同样也会在编译期进行计算。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ｑｔ操作mysql</title>
      <link>/2020/qt%E6%93%8D%E4%BD%9Cmysql/</link>
      <pubDate>Mon, 07 Dec 2020 18:12:25 +0800</pubDate>
      
      <guid>/2020/qt%E6%93%8D%E4%BD%9Cmysql/</guid>
      <description>

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;1-基本操作&#34;&gt;1. 基本操作&lt;/h1&gt;

&lt;h2 id=&#34;1-1-添加模块&#34;&gt;1.1 添加模块&lt;/h2&gt;

&lt;p&gt;Qt数据库模块是独立模块，需要像core，gui一样在.pro文件中添加该模块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;QT+=sql
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;1-2-基本操作&#34;&gt;1.2 基本操作&lt;/h1&gt;

&lt;h2 id=&#34;获取可用连接&#34;&gt;获取可用连接&lt;/h2&gt;

&lt;p&gt;首先查看qt下支持的连接名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;qDebug() &amp;lt;&amp;lt; QSqlDatabase::drivers();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下
&lt;code&gt;(&amp;quot;QSQLITE&amp;quot;, &amp;quot;QMYSQL&amp;quot;, &amp;quot;QMYSQL3&amp;quot;, &amp;quot;QPSQL&amp;quot;, &amp;quot;QPSQL7&amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;建立连接&#34;&gt;建立连接&lt;/h2&gt;

&lt;p&gt;使用上一步获取到的连接名作为&lt;strong&gt;&lt;em&gt;addDatabase&lt;/em&gt;&lt;/strong&gt;的第一个参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;QSqlDatabase db = QSqlDatabase::addDatabase(&amp;quot;QMYSQL&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就获取到mysql的句柄了
接下来是mysql的基本操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    db.setHostName(&amp;quot;localhost&amp;quot;);  // 假定数据库在本机
    db.setDatabaseName(&amp;quot;student&amp;quot;); // 打开数据库名
    db.setUserName(&amp;quot;root&amp;quot;);  // 数据库用户名
    db.setPassword(&amp;quot;123456&amp;quot;);  // 数据库密码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置完之后调用open()打开mysql数据库,完整代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    QSqlDatabase db = QSqlDatabase::addDatabase(&amp;quot;QMYSQL&amp;quot;);
    db.setHostName(&amp;quot;localhost&amp;quot;);  // 假定数据库在本机
    db.setDatabaseName(&amp;quot;server&amp;quot;); // 打开数据库名
    db.setUserName(&amp;quot;root&amp;quot;);  // 数据库用户名
    db.setPassword(&amp;quot;123456&amp;quot;);  // 数据库密码
    if (!db.open())
    {
        qDebug() &amp;lt;&amp;lt; &amp;quot;Failed to connect to root mysql!&amp;quot;;
    }
    else
    {
        qDebug() &amp;lt;&amp;lt; &amp;quot;open success!&amp;quot;;
    }
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;增删改查&#34;&gt;增删改查&lt;/h2&gt;

&lt;p&gt;数据库操作无非增删改查，基于我们获取到的句柄，我们可以对数据库进行操作。&lt;/p&gt;

&lt;p&gt;QSqlQuery类提供了一种执行和操作SQL语句的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;QSqlQuery sqlquery(db);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入数据Demo&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    //插入新数据
    QSqlQuery sql_query(db);
    sql_query.prepare(&amp;quot;insert into stu(name,stuID,sex,score) values(&#39;stu2&#39;,&#39;123123&#39;,&#39;1&#39;,&#39;&#39;70)&amp;quot;);
    if(!sql_query.exec())
    {
       qDebug()&amp;lt;&amp;lt;sql_query.lastError();
    }
    else
    {
        qDebug()&amp;lt;&amp;lt;&amp;quot;insert Success...&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询Demo&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    QSqlQuery sql_query(db);
    sql_query.prepare(&amp;quot;select * from stu&amp;quot;);
    if(!sql_query.exec())
    {
       qDebug()&amp;lt;&amp;lt;sql_query.lastError();
    }
    else
    {
       while(sql_query.next())
        {
           QString name = sql_query.value(&amp;quot;name&amp;quot;).toString();
           QString id = sql_query.value(&amp;quot;stuID&amp;quot;).toString();
           QString sex = sql_query.value(&amp;quot;sex&amp;quot;).toString();
            QString score = sql_query.value(&amp;quot;score&amp;quot;).toString();
            qDebug()&amp;lt;&amp;lt;QString(&amp;quot;Name:%1     ID:%2    sex:%3    score:%4&amp;quot;).arg(name).arg(id).arg(sex).arg(score);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329730_20200403142349526_31331.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-3-批量使用&#34;&gt;1.3 批量使用&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;2-driver-not-loaded错误处理&#34;&gt;2. driver not loaded错误处理&lt;/h1&gt;

&lt;h2 id=&#34;问题排查&#34;&gt;问题排查&lt;/h2&gt;

&lt;p&gt;第一次使用Qtmysql的库时容易看到qDebug有如下打印&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;QSqlDatabase: QMYSQL driver not loaded
QSqlDatabase: available drivers: QSQLITE QMYSQL QMYSQL3 QPSQL QPSQL7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329726_20200402173143995_5048.png&#34; alt=&#34;clipboard&#34; /&gt;
查看本机mysql，发现mysqlClient库安装正常&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls /usr/lib/x86_64-linux-gnu/libmysql* -lsd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329727_20200403101104397_31787.png&#34; alt=&#34;&#34; /&gt;
查看Qt数据组件sql是否正常
1）进入到Qt的安装目录下，进入对应编译器文件夹中，楼主的文件夹是
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329728_20200403101412861_21234.png&#34; alt=&#34;&#34; /&gt;
查看&lt;strong&gt;libqsqlmysql.so&lt;/strong&gt;文件链接是否正常&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ldd libqsqlmysql.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329728_20200403101545125_14714.png&#34; alt=&#34;&#34; /&gt;
结果发现Qt中mysql库链接的是18的版本，而当前环境没有该版本的mysql库&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;h3 id=&#34;1-下载对应版本的libsqlclient&#34;&gt;1.下载对应版本的libsqlclient&lt;/h3&gt;

&lt;p&gt;这个方式比较方便，适合绝大多数场景
* 下载地址： &lt;a href=&#34;https://launchpad.net/ubuntu/xenial/amd64/libmysqlclient18/5.6.25-0ubuntu1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://launchpad.net/ubuntu/xenial/amd64/libmysqlclient18/5.6.25-0ubuntu1&lt;/a&gt;
* 下载 libmysqlclient18_5.6.25-0ubuntu1_amd64.deb，然后 dpkg -i libmysqlclient18_5.6.25-0ubuntu1_amd64.deb 即可。&lt;/p&gt;

&lt;h3 id=&#34;2-重新编译qt中的libqsqlmysql库&#34;&gt;2.重新编译Qt中的libqsqlmysql库&lt;/h3&gt;

&lt;p&gt;进入安装时下载的Qt源码，在对应版本的SRC文件夹下，对该库的源码进行重新编译
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1600329729_20200403102316916_2297.png&#34; alt=&#34;&#34; /&gt;
最后将编译好的libqsqlmysql.so库放回原先的位置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LibCurl编译</title>
      <link>/2020/libcurl%E7%BC%96%E8%AF%91/</link>
      <pubDate>Sat, 05 Dec 2020 21:30:59 +0800</pubDate>
      
      <guid>/2020/libcurl%E7%BC%96%E8%AF%91/</guid>
      <description>

&lt;h1 id=&#34;libcurl编译&#34;&gt;libCurl编译&lt;/h1&gt;

&lt;p&gt;1.首先下载libCurl的源码，这里使用的是Github上的版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/curl/curl.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/curl/curl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.生成configure&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ./buildconf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.查看本地可开启的功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --enable-pthreads
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会显示默认环境下安装后能使用的功能，若是满足需求就直接make和sudo make install&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若要开启SSL support和zlib support:(Centos) yum install openssl-libs openssl-devel&lt;/li&gt;
&lt;li&gt;若要支持https需安装libssh2:(Centos) yum install libssh2-devel&lt;/li&gt;
&lt;li&gt;若要支持PSL 验证 Cookie 和证书的 Domain 信息，则安装libpsl:(Centos) yum psl libpsl-devel&lt;/li&gt;
&lt;li&gt;若要支持HTTP2 ,则安装nghttp2:(Centos) yum install libnghttp2-devel nghttp2&lt;/li&gt;
&lt;li&gt;若要支持IDN,则安装libidn:(Centos) yum install libidn2 libidn2-devel&lt;/li&gt;
&lt;li&gt;若要支持metalink，则安装 libmetalink:(Centos) yum install libmetalink libmetalink-devel&lt;/li&gt;
&lt;li&gt;若要支持RTMP实时流传输，则到官网下载安装,可以参考文章 &lt;a href=&#34;https://blog.csdn.net/dc_show/article/details/47130639&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;linux下编译支持librtmp、libx264、libfaac的ffmpeg&lt;/a&gt;
&lt;strong&gt;Ubuntu的可对应上面的centos库自行百度下载&lt;/strong&gt;
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609853471_20201221102836019_8153.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4.编译libcurl
由于本人需要openssl 与SSH2的功能（从上图可以看到SSH为未链接状态，我们可以下载libssh2进行编译）
&lt;strong&gt;编译OpenssH（可选）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; wget http://www.libssh2.org/download/libssh2-1.4.3.tar.gz
 tar -zxvf libssh2-1.4.3.tar.gz
 cd libssh2-1.4.3/
//由于我/usr/local的openssl版本太高了，编译会报错，所以使用低版本的openssl
 ./configure --prefix=/usr/local/libssh2 --with-openssl CPPFLAGS=&amp;quot;-I/usr/local/openssl/include&amp;quot; LDFLAGS=&amp;quot;-L/usr/local/openssl/lib&amp;quot;
make
make insatll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将openssh与openssl链接到libcurl中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;进入libcurl文件夹
./configure --prefix=/home/lin/libcurl/outputFile --enable-debug --with-openssl CPPFLAGS=&amp;quot;-I/home/lin/openssl/include&amp;quot; LDFLAGS=&amp;quot;-L/home/lin/openssl/lib&amp;quot; --with-libssh2 CPPFLAGS=&amp;quot;-I/usr/local/libssh2/include&amp;quot; LDFLAGS=&amp;quot;-L//usr/local/libssh2/lib&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到openssh的功能已经支持。
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609853471_20201221114118426_23030.png&#34; alt=&#34;&#34; /&gt;
需要其他的功能也是同理，这里就不展开讲了。&lt;/p&gt;

&lt;p&gt;5.编译与安装
接下来就是make与makeinstall了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make -j4 
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看设置输出的outputFile文件夹，已经编译成功
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609853472_20201221134804756_1652.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编译android对应版本的openssl</title>
      <link>/2020/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/</link>
      <pubDate>Thu, 05 Nov 2020 20:29:23 +0800</pubDate>
      
      <guid>/2020/%E7%BC%96%E8%AF%91android%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84openssl/</guid>
      <description>

&lt;h1 id=&#34;编译android对应版本的openssl&#34;&gt;编译android对应版本的openssl&lt;/h1&gt;

&lt;h2 id=&#34;版本&#34;&gt;版本&lt;/h2&gt;

&lt;p&gt;自行下载需要的NDK与openssl&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NDK: android-ndk-r15c
openssl：openssl-1.0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;下载交叉编译文件&#34;&gt;下载交叉编译文件&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#拉取setenv-android.sh，我们需要这个脚本来给我们配置环境
wget https://wiki.openssl.org/images/7/70/Setenv-android.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置脚本&#34;&gt;配置脚本&lt;/h2&gt;

&lt;h3 id=&#34;armv7a版本配置&#34;&gt;armv7a版本配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;_ANDROID_NDK=&amp;quot;android-ndk-r9&amp;quot;
# 修改为：
_ANDROID_NDK=&amp;quot;android-ndk-r15c&amp;quot;
# 因为我们使用的是R14B这个版本的NDK
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;_ANDROID_EABI=&amp;quot;arm-linux-androideabi-4.8&amp;quot;
修改为GCC 4.9
_ANDROID_EABI=&amp;quot;arm-linux-androideabi-4.9&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609853377_20200914133910597_16954.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;arm64v8a版本配置&#34;&gt;arm64V8A版本配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;_ANDROID_NDK=&amp;quot;android-ndk-r9&amp;quot;
# 修改为：
_ANDROID_NDK=&amp;quot;android-ndk-r15c&amp;quot;
# 因为我们使用的是r15c这个版本的NDK
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;_ANDROID_EABI=&amp;quot;arm-linux-androideabi-4.8&amp;quot;
修改为GCC 4.9
_ANDROID_EABI=&amp;quot;aarch64-linux-android-4.9&amp;quot;

_ANDROID_ARCH=arch-arm
修改为
_ANDROID_ARCH=arch-arm64

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;

&lt;p&gt;添加环境变量（仅在当前终端就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export ANDROID_NDK_ROOT=/home/ubuntu/android-ndk-r15c
 source ./Setenv-android.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FIPS_SIG的Error无所谓，本次不会使用到这个组件&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Opencv视频流处理方法</title>
      <link>/2020/opencv%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 15 Oct 2020 18:27:07 +0800</pubDate>
      
      <guid>/2020/opencv%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</guid>
      <description>

&lt;h1 id=&#34;opencv视频流处理方法&#34;&gt;opencv视频流处理方法&lt;/h1&gt;

&lt;p&gt;OpenCV提供了VideoCapture类和VideoWriter类来支持各种格式的视频流，支持的格式类型会因系统的不同而有所变化，但基本上都是支持avi格式的，且对于视频文件和摄像头画面的读写所用到的接口基本上都相同，因此，我们把它们放在一起来讲了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 获取VideoCapture类实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不管是读取视频文件还是捕获摄像头画面，都使用到了VideoCapture类，但不同的是传入的形参不一样，如果我们传给VideoCapture类的是一个视频文件路径那么将是读取来自视频文件的画面，而如果我们传给VideoCapture类的是摄像头编号那么将是读取来自摄像头的画面，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # 获取VideoCapture类实例，读取视频文件
    fcap = cv2.VideoCapture(&#39;demo.mp4&#39;)
    # 读取摄像头画面
    ccap = cv2.VideoCapture(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于摄像头编号，可以使用如下命令获取：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ls -al /dev/ | grep video
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于输出信息以video开头的其数字后缀即为可能的摄像头编号，如果一台电脑有多个摄像头设备，那么将会出现从0开始的多个摄像头编号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 判断获取VideoCapture实例是否成功&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果传入无效的视频文件或摄像头编号，那么VideoCapture类将会在后续的read()接口返回（False，None），为了避免此类事件发生，可以通过VideoCapture类的isOpened()接口进行判断，该接口返回一个boolean值，正常获取实例返回True，否则返回False，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # 判断是否正确获取VideoCapture类实例
    while fcap.isOpened():
        # next step operation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. 获取视频流信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般视频流主要的帧信息包含画面宽高还有帧率，对于视频文件，则会多出整个视频流多少帧，因此，我们一般主要关注这四个视频流信息即可，而我们用到的则是VideoCapture类的get接口，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # 获取视频帧的宽
    w = fcap.get(cv2.CAP_PROP_FRAME_WIDTH)
    # 获取视频帧的高
    h = fcap.get(cv2.CAP_PROP_FRAME_HEIGHT)
    # 获取视频帧的帧率
    fps = fcap.get(cv2.CAP_PROP_FPS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取到的帧率对于摄像头设备来说，如果所使用的终端不支持查询，那么将会返回0值，且该值也不是非常精确的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    # 获取视频流的总帧数
    fcount = fcap.get(cv2.CAP_PROP_FRAME_COUNT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这个是对视频文件才有意义，对于摄像头是没意义的，且以上获取到的返回信息均是浮点型的，注意转换为整型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 获取帧画面&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个就相对简单，直接使用VideoCapture类的read接口即可，该接口会返回两个参数，第一个参数是读取成功与否标志位，成功为True否则为False，第二个参数则为具体的帧数据，其是一个numpy.ndarray的数组，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # 获取帧画面
    success, frame = fcap.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但在读取过程中，有可能会存在失败的情况出现，一般我们是在第二次读取时放入一个while循环来保障整个读取顺利进行，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # 判断读取视频流是否成功
    while success:
        success, frame = fcap.read()
        # do something in here

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5. 针对一组或多头摄像头特殊处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当需要同步一组摄像头或一个多头（multihead）摄像头（例如立体摄像头或Kinect）时，read()方法就不太适用了，这时，一般使用grab()和retrieve()方法代替它。对于一组摄像头，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    # 一组摄像头的特殊处理
    success0 = fcap0.grab()
    success1 = fcap1.grab()
    if success0 and success1:
        frame0 = fcap0.retrieve()
        frame1 = fcap1.retrieve()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6. 跳到视频流某一帧&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于视频文件，有时候我们需要直接跳到某一个感兴趣的帧并从该帧开始读取数据，那么可以使用VideoCapture类的set接口，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    # 跳到某一感兴趣帧并从此帧开始读取,如从第360帧开始读取
    fcap.set(cv2.CAP_PROP_POS_FRAMES, 360)
    success, frame = fcap.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;7. 设置摄像头分辨率&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;opencv读取到的摄像头画面大小一般为默认的640x480，但这并不一定满足我们的日常使用要求，比如摄像头支持超高清画面，那么我们就希望能捕获到超高清1920x1080的画面，好在VideoCapture类的set接口为我们提供了相应的功能，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # 设置摄像头分辨率的高
    fcap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080)
    # 设置摄像头分辨率的宽
    fcap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;8. 获取VideoWriter类实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不管是对视频文件的再存储还是对摄像头画面的保存，都是用到了VideoWriter类，且传入的形参意义是一致的，都需要我们传入保存的文件名包含视频格式、指定视频编解码器、保存视频的帧率以及保存视频的分辨率，一般来说，保存视频的帧率最好与读入的画面的帧率一致，但需要我们进行估计或使用计时器才会比较准确，而分辨率则可以更改，只是要求写入的帧其大小要与分辨率保持一致，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;writer = cv2.VideoWriter(&#39;output.avi&#39;, cv2.VideoWriter_fourcc(&#39;X&#39;, &#39;V&#39;, &#39;I&#39;, &#39;D&#39;), 30, (1080, 1920))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是，我们必须要为VideoWriter类的构造函数传入所需的参数，且若指定的文件名已存在则会被直接覆盖。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9. VideoWriter类支持的视频编解码器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在构造VideoWriter类实例时，我们必须要指定视频编解码器，那么VideoWriter类都支持哪些视频编解码器呢？我们通过cv2.VideoWriter_fourcc来指定具体使用的编解码器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;：该选项是一个未压缩的YUV颜色编码，兼容性好，但产生文件较大，文件扩展名为.avi
    &#39;P&#39;,&#39;T&#39;,&#39;M&#39;,&#39;I&#39;：该选项是MPEG-1编码类型，文件扩展名为.avi
    &#39;X&#39;,&#39;V&#39;,&#39;T&#39;,&#39;D&#39;：该选项是MPEG-4编码类型，得到的视频大小处于平均值，文件扩展名为.avi
    &#39;T&#39;,&#39;H&#39;,&#39;E&#39;,&#39;O&#39;：该选项是Ogg Vorbis，文件扩展名为.ogv
    &#39;F&#39;,&#39;L&#39;,&#39;V&#39;,&#39;1&#39;：该选项是一个flash视频，文件扩展名为.flv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般常用的是cv2.VideoWriter_fourcc(&amp;lsquo;X&amp;rsquo;,&amp;lsquo;V&amp;rsquo;,&amp;rsquo;T&amp;rsquo;,&amp;rsquo;D&amp;rsquo;)，mp4编码文件相对小一些，或cv2.VideoWriter_fourcc(&amp;lsquo;I&amp;rsquo;,&amp;lsquo;4&amp;rsquo;,&amp;lsquo;2&amp;rsquo;,&amp;lsquo;0&amp;rsquo;)，文件相对大一些，但为了缩小文件空间我们可能还需要用到ffmpeg工具进一步压缩文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10. 保存帧数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个也很简单，直接使用VideoWriter类的write接口即可，该接口一次可以保存一帧数据到制定文件中，其使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 保存帧数据
writer.write(frame)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;11. 释放资源&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不管是VideoCapture类还是VideoWriter类，当我们使用完了它们之后，都应该将它们释放掉，避免资源一直被占用，而这两个类都有提供了release()接口给我们，我们只需直接调用即可释放资源，使用示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # 释放VideoCapture资源
    fcap.release()
    # 释放VideoWriter资源
    writer.release()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;12. 一个完整的示例代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # -*- coding: utf-8 -*-
    # /usr/bin/env/python3
    
    &#39;&#39;&#39;use opencv3 to capture video frame, show and save its stream.&#39;&#39;&#39;
    
    import cv2
    
    def stream_processing():
        # 获取VideoCapture类实例，读取视频文件
        fcap = cv2.VideoCapture(&#39;demo.mp4&#39;)
    
        # 设置摄像头分辨率的高
        fcap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080)
        # 设置摄像头分辨率的宽
        fcap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920)
        # 跳到某一感兴趣帧并从此帧开始读取,如从第360帧开始读取
        fcap.set(cv2.CAP_PROP_POS_FRAMES, 360)
    
        # 获取视频帧的宽
        w = fcap.get(cv2.CAP_PROP_FRAME_WIDTH)
        # 获取视频帧的高
        h = fcap.get(cv2.CAP_PROP_FRAME_HEIGHT)
        # 获取视频帧的帧率
        fps = fcap.get(cv2.CAP_PROP_FPS)
        # 获取视频流的总帧数
        fcount = fcap.get(cv2.CAP_PROP_FRAME_COUNT)
        
        # 获取VideoWriter类实例
        writer = cv2.VideoWriter(&#39;output.avi&#39;, cv2.VideoWriter_fourcc(&#39;X&#39;, &#39;V&#39;, &#39;I&#39;, &#39;D&#39;), int(fps), (int(w), int(h)))
    
        # 判断是否正确获取VideoCapture类实例
        while fcap.isOpened():
            # 获取帧画面
            success, frame = fcap.read()
            while success:
                cv2.imshow(&amp;quot;demo&amp;quot;, frame)  ## 显示画面
                # 获取帧画面
                success,frame = fcap.read()
    
                # 保存帧数据
                writer.write(frame)
    
                if (cv2.waitKey(20) &amp;amp; 0xff) == ord(&#39;q&#39;):  ## 等待20ms并判断是按“q”退出，相当于帧率是50hz，注意waitKey只能传入整数，
                    break
            # 释放VideoCapture资源
            fcap.release()
        # 释放VideoWriter资源
        writer.release()
        cv2.destroyAllWindows()  ## 销毁所有opencv显示窗口
    
    
    if __name__ == &amp;quot;__main__&amp;quot;:
        stream_processing()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>VLC编译</title>
      <link>/2020/vlc%E7%BC%96%E8%AF%91/</link>
      <pubDate>Sat, 05 Sep 2020 21:24:17 +0800</pubDate>
      
      <guid>/2020/vlc%E7%BC%96%E8%AF%91/</guid>
      <description>

&lt;h1 id=&#34;vlc编译&#34;&gt;VLC编译&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;git clone git://github.com/vlc-qt/vlc-qt.git
sudo apt install libvlc-dev


sudo apt-get install snapd
sudo apt-get install snapcraft 
sudo snap install vlc


export QTDIR=/Qt安装路径/5.12.3/gcc_64
export LD_LIBRARY_PATH=$QTDIR/lib
export PATH=$PATH:$QTDIR/bin


sudo  cmake .. -DCMAKE_BUILD_TYPE=Debug
sudo make -j8
sudo make install


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;core libvlc error: No plugins found! Check your VLC installation.
VLC-Qt Error: libvlc failed to load!

sudo apt-get install libvlc-dev
sudo apt-get install vlc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;CMake Error at config/Dependencies.cmake:28 (FIND_PACKAGE):
  By not providing &amp;quot;FindQt5Core.cmake&amp;quot; in CMAKE_MODULE_PATH this project has
  asked CMake to find a package configuration file provided by &amp;quot;Qt5Core&amp;quot;, but
  CMake did not find one.
1、打开vlc-qt源码目录下的CMakeLists.txt

2、在SET(PROJECT_DESCRIPTION &amp;quot;VLC-Qt - Qt bindings for libVLC&amp;quot;)下方添加一行

    SET(CMAKE_PREFIX_PATH &amp;quot;/opt/Qt5.6.2/5.6/gcc_64&amp;quot;)

注意一点的是CMAKE_PREFIX_PATH的目录的指向必须是在包含有bin lib include等这些QT的安装目录。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;USB摄像头权限不足时&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
snap connections vlc
查看是否允许访问设备


 snap connect vlc:camera :camera
这将在接口和插槽之间建立连接：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ffmpeg安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install -y autoconf automake build-essential git libass-dev libfreetype6-dev libsdl2-dev libtheora-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev pkg-config texinfo wget zlib1g-dev

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Docker实例</title>
      <link>/2020/docker%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Tue, 05 May 2020 21:21:43 +0800</pubDate>
      
      <guid>/2020/docker%E5%AE%9E%E4%BE%8B/</guid>
      <description>

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;1-docker实例&#34;&gt;1. docker实例&lt;/h1&gt;

&lt;p&gt;下面使用ubuntu:18.04作为例子&lt;/p&gt;

&lt;h2 id=&#34;1-1-镜像使用&#34;&gt;1.1. 镜像使用&lt;/h2&gt;

&lt;h3 id=&#34;1-1-1-获取镜像&#34;&gt;1.1.1. 获取镜像&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;docker pull ubuntu:18.04
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待下载完成后,查看宿主机镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker images 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看刚刚下载下来的镜像
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940599_20200414165447335_17775.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-1-2-运行镜像&#34;&gt;1.1.2. 运行镜像&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;docker run -it  ubuntu:18.04  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时我们即启动了该镜像
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940600_20200414170404824_23488.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940600_20200414170507937_18320.png&#34; alt=&#34;&#34; /&gt;
此处需要说明，每一次使用镜像运行，都会生成一个容器,退出的容器并不会立即删除，除非手动 docker rm,如果不需要排障和保留结果可以使用以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -it  --rm ubuntu:18.04  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;ndash;rm 参数使docker不会保留该容器，会在容器退出后将其删除&lt;/p&gt;

&lt;h3 id=&#34;1-1-3-操作容器&#34;&gt;1.1.3. 操作容器&lt;/h3&gt;

&lt;p&gt;当使用&lt;strong&gt;docker run -it  ubuntu:18.04  bash&lt;/strong&gt;会在本地生成一个容器，容器和镜像的关系相当于对象和类，查看本地容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940600_20200415142739990_7538.png&#34; alt=&#34;&#34; /&gt;
启动一个已经停止的容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker start b8ed1b0ee812 //containerID/name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;捕获一个正在运行的容器，使其转到前台bash&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker attach b8ed1b0ee812 //containerID/name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;attach捕获后推出容器，此容器会停止，如果想推出后继续在后台运行使用exec命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker exec -it b8ed1b0ee812 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-1-4-网络端口映射&#34;&gt;1.1.4. 网络端口映射&lt;/h3&gt;

&lt;p&gt;当在docker中的服务需要监听宿主机的某些网络应用时，我们使用网络端口映射来达成访问。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -itd -p 5000:5000 ubuntu bash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;-p&lt;/strong&gt; 是容器内部端口绑定到指定的主机端口。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;-P&lt;/strong&gt; 是容器内部端口随机映射到主机的高端口。
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940602_20200415150710911_3372.png&#34; alt=&#34;&#34; /&gt;
查看结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940602_20200415150900679_2631.png&#34; alt=&#34;&#34; /&gt;
绑定特殊IP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -itd -p 127.0.0.1:5000:5000 ubuntu bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用udp&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -itd -p 127.0.0.1:5000:5000/udp ubuntu bash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-1-5-创建镜像&#34;&gt;1.1.5. 创建镜像&lt;/h3&gt;

&lt;p&gt;如果从仓库下载的镜像无法满足我们的使用需求，我们有两种方案修改镜像。
- 使用dockerFile自定义镜像
- 使用commit修改镜像&lt;/p&gt;

&lt;h4 id=&#34;1-1-5-1-commit修改镜像&#34;&gt;1.1.5.1. commit修改镜像&lt;/h4&gt;

&lt;p&gt;有时需要在镜像中安装一些软件，又不需要重新搭建环境，这是可以从已经创建的容器中更新镜像，并且提交这个镜像。就可以得到一个修改过的镜像
进入镜像中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker exec -it b8ed1b0ee812 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子我们对容器进行ping工具安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940600_20200415144915573_7417.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install inetutils-ping
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940601_20200415145007590_1471.png&#34; alt=&#34;&#34; /&gt;
此时&lt;strong&gt;ping&lt;/strong&gt;安装完成，使用exit退出容器，使用该容器对镜像进行更新&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker commit -m=&amp;quot;has update&amp;quot; -a=&amp;quot;linjg&amp;quot; b8ed1b0ee812 testimage/pingubuntu:v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各个参数说明:
- &lt;strong&gt;-m&lt;/strong&gt;  提交的描述信息
- &lt;strong&gt;-a&lt;/strong&gt;  作者
- &lt;strong&gt;b8ed1b0ee812&lt;/strong&gt;  容器ID
- &lt;strong&gt;testimage/pingubuntu:v2&lt;/strong&gt;  创建的镜像名&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940601_20200415145244734_18760.png&#34; alt=&#34;&#34; /&gt;
镜像提交成功后我们查看镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940601_20200415145411271_23764.png&#34; alt=&#34;&#34; /&gt;
镜像提交完成
这时候使用该镜像再次生成容器，容器内便会自带ping命令，同理其他程序也可如此操作&lt;/p&gt;

&lt;h4 id=&#34;1-1-5-2-dockerfile定制镜像&#34;&gt;1.1.5.2. dockerFile定制镜像&lt;/h4&gt;

&lt;p&gt;Dockerfile 是一个文本文件，其内包含了一条条的 &lt;strong&gt;指令(Instruction)&lt;/strong&gt;，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。
在一个空白目录中新建一个Dockerfile文件添加内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; FROM testimage/pingubuntu:v2
 RUN apt-get update
 RUN apt install -y build-essential
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FROM为此dockerfile构建的基础镜像，run指令是用来执行命令行命令。上文例子为安装GCC编译器例子。
此处主要讲制作流程，更多指令请参考docker官方文档:&lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://docs.docker.com/engine/reference/builder/&lt;/a&gt;
保存Dockerfile文件并执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t dockfileimage:v3 .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker会对程序进行构建,等待镜像构建完成
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940602_20200415153616761_23486.png&#34; alt=&#34;&#34; /&gt;
耐心等待构建完成后，即可看到自己定制的docker镜像
&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940603_20200415154436105_29555.png&#34; alt=&#34;&#34; /&gt;
生成容器查看是否正常。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -it  --rm dockfileimage:v3  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看插入的gcc环境是否正常&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1586940603_20200415154631898_5299.png&#34; alt=&#34;&#34; /&gt;
构建成功&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker常用命令</title>
      <link>/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 06 Apr 2020 21:19:44 +0800</pubDate>
      
      <guid>/2020/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>

&lt;h1 id=&#34;docker常用命令&#34;&gt;docker常用命令&lt;/h1&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;h3 id=&#34;1-helloworld的调用&#34;&gt;1.helloworld的调用&lt;/h3&gt;

&lt;p&gt;从仓库将image抓取到本地&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker image pull library/hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;docker image pull&lt;/strong&gt;是抓取image文件的命令。&lt;strong&gt;ibrary/hello-world&lt;/strong&gt;是镜像文件在仓库的位置，其中library是image文件所在的组，hello-world是 image 文件的名字。&lt;/p&gt;

&lt;p&gt;获得管理员权限（对宿主机的访问）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; docker run -it --privileged  --rm ubuntu:18.04  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看本地镜像文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker image ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行镜像，会生成一个容器实例，镜像和容器的关系就像是类和对象的关系。
查看当前所有容器
&amp;gt; docker container ls&lt;/p&gt;

&lt;p&gt;查看当前电脑所有容器，包括终止运行的容器
&amp;gt; docker container ls &amp;ndash;all&lt;/p&gt;

&lt;p&gt;终止运行的容器文件，依然会占据硬盘空间，下面是删除指令
&amp;gt; docker container rm [containerID]&lt;/p&gt;

&lt;p&gt;除过以上我们使用的Docker命令外，Docker还有一些其它常用的命令&lt;/p&gt;

&lt;p&gt;拉取docker镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker pull image_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置docker开机自启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从镜像中构建容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -it  ubuntu:18.04  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从镜像中构建容器，退出容器后不保留容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -it  --rm ubuntu:18.04  bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开机自启动容器
docker update &amp;ndash;restart=always xxx&lt;/p&gt;

&lt;p&gt;查看宿主机上的镜像，Docker镜像保存在/var/lib/docker目录下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker rmi  docker.io/tomcat:7.0.77-jre7   或者  docker rmi b39c68b7af30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看当前有哪些容器正在运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看所有容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动、停止、重启容器命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker start container_name/container_id
docker stop container_name/container_id
docker restart container_name/container_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后台启动一个容器后，如果想进入到这个容器，可以使用attach命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker attach container_name/container_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除容器的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker rm container_name/container_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看当前系统Docker信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker info
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从Docker hub上下载某个镜像:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker pull centos:latest
docker pull centos:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行docker pull centos会将Centos这个仓库下面的所有镜像下载到本地repository。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker安装</title>
      <link>/2020/docker%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sun, 05 Apr 2020 21:18:19 +0800</pubDate>
      
      <guid>/2020/docker%E5%AE%89%E8%A3%85/</guid>
      <description>

&lt;h1 id=&#34;docker安装&#34;&gt;docker安装&lt;/h1&gt;

&lt;p&gt;## 安装&lt;/p&gt;

&lt;h3 id=&#34;1-卸载旧版本&#34;&gt;1.卸载旧版本&lt;/h3&gt;

&lt;p&gt;Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。如果已安装，请卸载它们：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get remove docker docker-engine docker.io containerd runc
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-使用-apt-安装&#34;&gt;2.使用 APT 安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 apt 依赖包，用于通过HTTPS来获取仓库:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥
添加 Docker 的官方 GPG 密钥：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl \-fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt\-key add \-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-key fingerprint 0EBFCD88
   
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) &amp;lt;docker@docker.com&amp;gt;
sub   rsa4096 2017-02-22 [S]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装-docker-engine-community&#34;&gt;安装 Docker Engine-Community&lt;/h2&gt;

&lt;p&gt;安装最新版本的 Docker Engine-Community 和 containerd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;修改image-仓库的镜像网址&#34;&gt;修改image 仓库的镜像网址&lt;/h2&gt;

&lt;p&gt;国内访问 Docker 的官方仓库很慢，还经常断线，所以要把仓库网址改成国内的镜像站。
打开/etc/default/docker文件（需要sudo权限)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gedit /etc/default/docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在文件的底部加上一行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DOCKER_OPTS=&amp;quot;--registry-mirror=https://registry.docker-cn.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，重启 Docker 服务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo service docker restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就会自动从镜像仓库下载 image 文件了。&lt;/p&gt;

&lt;h2 id=&#34;测试-docker-是否安装成功&#34;&gt;测试 Docker 是否安装成功&lt;/h2&gt;

&lt;p&gt;测试 Docker 是否安装成功，输入以下指令，打印出以下信息则安装成功:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker run hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/linMentri/mapdepot/raw/master/1609852747_20200414151848751_30290.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>&lt;p&gt;Hugo is the &lt;strong&gt;world’s fastest framework for building websites&lt;/strong&gt;. It is written in Go.&lt;/p&gt;

&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/russross/blackfriday&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/russross/blackfriday&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alecthomas/chroma&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/alecthomas/chroma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/muesli/smartcrop&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/muesli/smartcrop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/spf13/cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/spf13/viper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>